<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Generator</title>
    <style>
        /* --- General Styling --- */
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align top for longer content */
            min-height: 100vh;
            background-color: #f0f0f0;
            padding-top: 20px; /* Add some space at the top */
            padding-bottom: 40px; /* Add space at bottom */
        }

        .container {
            text-align: center;
            background-color: #fff;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        h1 {
            margin-top: 0;
            margin-bottom: 0;
            color: #333;
        }

        /* --- Controls --- */
        .controls {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px; /* Spacing between control rows */
        }

        .controls-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px; /* Space between controls in a row */
            flex-wrap: wrap; /* Allow wrapping for smaller screens */
            width: 100%; /* Full width for controls */
        }

        .controls label, /* General label for difficulty */
        .controls select,
        .controls button {
            padding: 8px 12px;
            font-size: 1em;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .controls select {
            cursor: pointer;
        }
        .controls button {
            cursor: pointer;
            background-color: #e7e7e7;
            transition: background-color 0.2s;
        }
        .controls button:hover {
            background-color: #d7d7d7;
        }
        .controls button#new-game-btn {
            background-color: #4CAF50; /* Green */
            color: white;
            border-color: #4CAF50;
        }
        .controls button#new-game-btn:hover {
            background-color: #45a049;
        }

        /* Styling for new toggles */
        .toggle-option {
            display: flex;
            align-items: center;
            gap: 4px; /* Space between checkbox and its label text */
        }
        .toggle-option label { /* Specific styling for toggle labels */
            font-size: 0.9em;
            cursor: pointer;
            padding: 0; /* Override general .controls label padding */
            border: none; /* Override general .controls label border */
            margin-right: 5px; /* Space after the toggle group if needed */
        }
        .toggle-option input[type="checkbox"] {
            cursor: pointer;
            vertical-align: middle; /* Align checkbox better with text */
        }


        /* --- Sudoku Grid --- */
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            /* Responsive width, max-width */
            width: clamp(300px, 90vmin, 450px);
            height: clamp(300px, 90vmin, 450px);
            border: 3px solid #333;
            margin: 20px auto;
            box-sizing: border-box;
        }

        .cell {
            position: relative; /* Needed for absolute positioning of value/notes */
            border: 1px solid #ccc;
            box-sizing: border-box;
            display: flex; /* Use flex for centering value later */
            justify-content: center;
            align-items: center;
            cursor: pointer;
            background-color: #fff;
            transition: background-color 0.2s;
        }

        /* Add thicker lines for 3x3 boxes */
        .cell:nth-child(9n) { border-right: 3px solid #333; }
        .cell:nth-child(n):nth-child(-n+9) { border-top: 3px solid #333; }
        .cell:nth-child(n+73) { border-bottom: 3px solid #333; }
        .cell:nth-child(9n+1) { border-left: 3px solid #333; }

        .cell:nth-child(3n) { border-right: 2px solid #555; }
        .cell:nth-child(9n+1), .cell:nth-child(9n+4), .cell:nth-child(9n+7) { border-left: 2px solid #555; }
        .cell:nth-child(n+19):nth-child(-n+27), .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid #555; }


        .cell.selected {
            background-color: #e0f7fa;
        }

        .cell.highlight {
            background-color: #f0f0f0;
        }
        .cell.highlight.selected {
            background-color: #e0f7fa;
        }

        .cell.initial {
            background-color: #eee;
            font-weight: bold;
        }

        .cell.conflicting {
            background-color: #ffebee;
        }
        .cell.conflicting:not(.initial) .value {
            color: #b71c1c;
        }

        .cell:not(.initial).user-wrong .value {
            color: #d32f2f;
        }
        .cell.conflicting:not(.initial).user-wrong .value {
            color: #b71c1c;
        }


        /* --- Notes Grid --- */
        .notes-grid {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            padding: 1px;
            box-sizing: border-box;
            pointer-events: none;
        }

        .note-cell {
            font-size: clamp(0.5em, 2vmin, 0.7em);
            color: #aaa;
            display: flex;
            justify-content: center;
            align-items: center;
            visibility: hidden;
            line-height: 1;
            font-weight: normal;
        }

        .note-cell.visible {
            visibility: visible;
        }

        .note-cell.hidden-single { /* Will be applied if toggled on */
            font-weight: bold;
            color: #666; /* Darker color for hidden single notes */
        }

        /* --- Cell Value --- */
        .value {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.5em, 5vmin, 2em);
            color: #007bff;
            z-index: 1;
            pointer-events: none;
        }

        .cell.initial .value {
            color: #333;
        }

        /* --- Number Pad --- */
        .number-pad {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 5px;
        }

        .num-btn {
            font-size: clamp(1em, 3vmin, 1.2em);
            width: clamp(35px, 9vmin, 45px);
            height: clamp(35px, 9vmin, 45px);
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f8f8f8;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
        }

        .num-btn.selected {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .num-btn:not(.selected):hover {
            background-color: #e0e0e0;
        }

        .num-btn.selected:hover {
            background-color: #0056b3;
        }

        .num-btn.erase {
            background-color: #fdd;
            color: #d32f2f;
            border-color: #fbc;
        }
        .num-btn.erase.selected {
            background-color: #d32f2f;
            color: white;
            border-color: #b71c1c;
        }
        .num-btn.erase:not(.selected):hover {
            background-color: #fbb;
        }
        .num-btn.erase.selected:hover {
            background-color: #b71c1c;
        }

        /* --- Status Message --- */
        #status-message {
            margin-top: 15px;
            font-weight: bold;
            min-height: 1.2em;
            color: #4CAF50;
        }

        /* --- Disabled Number Button Styling --- */
        .num-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f0f0f0;
            color: #aaa;
            border-color: #ddd;
        }
        .num-btn:disabled:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sudoku</h1>
        <div class="controls">
            <div class="controls-row">
                <label for="difficulty">Difficulty:</label>
                <select id="difficulty">
                    <option value="easy">Easy</option>
                    <option value="normal" selected>Normal</option>
                    <option value="hard">Hard</option>
                    <option value="expert">Expert</option>
                    <option value="custom">Custom</option>
                </select>
                <button id="new-game-btn">New Game</button>
            </div>

            <div class="controls-row">
                <!-- New Toggles -->
                <div class="toggle-option">
                    <input type="checkbox" id="auto-notes-toggle">
                    <label for="auto-notes-toggle">Auto Notes</label>
                </div>
                <div class="toggle-option">
                    <input type="checkbox" id="bold-hidden-singles-toggle">
                    <label for="bold-hidden-singles-toggle">Bold Hidden Singles</label>
                </div>
            </div>
        </div>

        <div id="sudoku-grid" class="sudoku-grid">
            <!-- 81 cells will be generated here by JavaScript -->
        </div>

        <div id="number-pad" class="number-pad">
            <button class="num-btn" data-number="1">1</button>
            <button class="num-btn" data-number="2">2</button>
            <button class="num-btn" data-number="3">3</button>
            <button class="num-btn" data-number="4">4</button>
            <button class="num-btn" data-number="5">5</button>
            <button class="num-btn" data-number="6">6</button>
            <button class="num-btn" data-number="7">7</button>
            <button class="num-btn" data-number="8">8</button>
            <button class="num-btn" data-number="9">9</button>
            <button class="num-btn erase" data-number="0">Del</button>
        </div>

        <p id="status-message"></p>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridElement = document.getElementById('sudoku-grid');
            const numberPad = document.getElementById('number-pad');
            const difficultySelect = document.getElementById('difficulty');
            const newGameBtn = document.getElementById('new-game-btn');
            const statusMessage = document.getElementById('status-message');

            // Toggles
            const autoNotesToggle = document.getElementById('auto-notes-toggle');
            const boldHiddenSinglesToggle = document.getElementById('bold-hidden-singles-toggle');

            const SIZE = 9;
            const BOX_SIZE = 3;

            let currentGrid = [];
            let solvedGrid = [];
            let initialGrid = [];
            let selectedCell = null;
            let selectedNumber = null;
            let isGenerating = false;
            let isCustomMode = false;

            // Toggle states
            let autoNotesEnabled = false;
            let boldHiddenSinglesEnabled = false;


            const difficultySettings = {
                easy: 45,
                normal: 36,
                hard: 28,
                expert: 22,
            };

            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            function countSolutions(grid) {
                let count = 0;
                function solve() {
                    const find = findEmpty(grid);
                    if (!find) {
                        count++;
                        return;
                    }
                    const [row, col] = find;
                    for (let num = 1; num <= SIZE && count < 2; num++) {
                        if (isValid(grid, row, col, num)) {
                            grid[row][col] = num;
                            solve();
                            if (count >= 2) {
                                grid[row][col] = 0;
                                return;
                            }
                            grid[row][col] = 0;
                        }
                    }
                }
                let gridCopy = grid.map(row => [...row]);
                solve();
                return count;
            }


            function setupNewGame() {
                if (isGenerating) return;
                isGenerating = true;
                clearSelection();
                gridElement.style.opacity = '0.5';

                const selectedDifficulty = difficultySelect.value;
                isCustomMode = (selectedDifficulty === 'custom');

                if (isCustomMode) {
                    statusMessage.textContent = "Custom Mode: Fill the grid.";
                    setupCustomGrid();
                } else {
                    statusMessage.textContent = `Generating ${selectedDifficulty} puzzle...`;
                    generatePuzzle();
                }
            }

            function setupCustomGrid() {
                 setTimeout(() => {
                    currentGrid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
                    initialGrid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
                    solvedGrid = [];

                    renderGrid();
                    updateAllNotes(); // This will respect autoNotesEnabled and updateHiddenSingleNotesStyling
                    updateNumberPadState();
                    statusMessage.textContent = "Custom Mode: Fill the grid.";
                    gridElement.style.opacity = '1';
                    isGenerating = false;
                 }, 10);
            }


            function generatePuzzle() {
                setTimeout(() => {
                    let grid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
                    if (!fillGrid(grid)) {
                        console.error("Failed to generate a fully solved grid.");
                        statusMessage.textContent = "Error generating puzzle. Try again.";
                        gridElement.style.opacity = '1';
                        isGenerating = false;
                        return;
                    }
                    solvedGrid = grid.map(row => [...row]);

                    const difficulty = difficultySelect.value;
                    const cellsToKeep = difficultySettings[difficulty] || difficultySettings.normal;
                    currentGrid = pokeHoles(solvedGrid, cellsToKeep);
                    initialGrid = currentGrid.map(row => [...row]);

                    renderGrid();
                    updateAllNotes(); // This will respect autoNotesEnabled and updateHiddenSingleNotesStyling
                    updateNumberPadState();
                    statusMessage.textContent = "";
                    gridElement.style.opacity = '1';
                    isGenerating = false;
                }, 50);
            }

            function fillGrid(grid) {
                const find = findEmpty(grid);
                if (!find) return true;
                const [row, col] = find;
                const numbers = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                for (let num of numbers) {
                    if (isValidForGeneration(grid, row, col, num)) {
                        grid[row][col] = num;
                        if (fillGrid(grid)) return true;
                        grid[row][col] = 0;
                    }
                }
                return false;
            }

            function findEmpty(grid) {
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        if (grid[r][c] === 0) return [r, c];
                    }
                }
                return null;
            }

            function isValidForGeneration(grid, row, col, num) {
                for (let c = 0; c < SIZE; c++) {
                    if (grid[row][c] === num) return false;
                }
                for (let r = 0; r < SIZE; r++) {
                    if (grid[r][col] === num) return false;
                }
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let r = startRow; r < startRow + BOX_SIZE; r++) {
                    for (let c = startCol; c < startCol + BOX_SIZE; c++) {
                        if (grid[r][c] === num) return false;
                    }
                }
                return true;
            }

            function isValid(grid, row, col, num) {
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let i = 0; i < SIZE; i++) {
                    if (grid[row][i] === num && i !== col) return false;
                    if (grid[i][col] === num && i !== row) return false;
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    if (grid[boxR][boxC] === num && (boxR !== row || boxC !== col)) return false;
                }
                return true;
            }

            function pokeHoles(solvedGridInput, cellsToKeep) {
                let puzzleGrid = solvedGridInput.map(row => [...row]);
                let cellsRemoved = 0;
                const targetCellsToRemove = SIZE * SIZE - cellsToKeep;
                let candidates = [];
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        candidates.push([r, c]);
                    }
                }
                shuffle(candidates);
                for (let i = 0; i < candidates.length && cellsRemoved < targetCellsToRemove; i++) {
                    const [r, c] = candidates[i];
                    if (puzzleGrid[r][c] === 0) continue;
                    let backup = puzzleGrid[r][c];
                    puzzleGrid[r][c] = 0;
                    let gridCopyForCheck = puzzleGrid.map(row => [...row]);
                    let numberOfSolutions = countSolutions(gridCopyForCheck);
                    if (numberOfSolutions !== 1) {
                        puzzleGrid[r][c] = backup;
                    } else {
                        cellsRemoved++;
                    }
                }
                return puzzleGrid;
            }


            function createGridDOM() {
                gridElement.innerHTML = '';
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        const notesGrid = document.createElement('div');
                        notesGrid.classList.add('notes-grid');
                        for (let n = 1; n <= SIZE; n++) {
                            const noteCell = document.createElement('div');
                            noteCell.classList.add('note-cell');
                            noteCell.dataset.note = n;
                            noteCell.textContent = n;
                            notesGrid.appendChild(noteCell);
                        }
                        cell.appendChild(notesGrid);
                        const valueDiv = document.createElement('div');
                        valueDiv.classList.add('value');
                        cell.appendChild(valueDiv);
                        cell.addEventListener('click', handleCellClick);
                        gridElement.appendChild(cell);
                    }
                }
            }

            function renderGrid() {
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        const cellElement = getCellElement(r, c);
                        if (!cellElement) continue;
                        const valueDiv = cellElement.querySelector('.value');
                        const notesGrid = cellElement.querySelector('.notes-grid');
                        const value = currentGrid[r][c];

                        cellElement.classList.remove('initial', 'conflicting', 'selected', 'highlight', 'user-wrong');
                        valueDiv.textContent = '';
                        notesGrid.style.display = 'grid';

                        if (value !== 0) {
                            valueDiv.textContent = value;
                            notesGrid.style.display = 'none';
                            if (!isCustomMode && initialGrid[r][c] !== 0) {
                                cellElement.classList.add('initial');
                            } else {
                                if (!isCustomMode && solvedGrid.length > 0 && value !== solvedGrid[r][c]) {
                                    cellElement.classList.add('user-wrong');
                                }
                            }
                        } else {
                            notesGrid.style.display = 'grid';
                        }
                    }
                }
                if (selectedCell) {
                    highlightAffectedCells(selectedCell.row, selectedCell.col);
                    getCellElement(selectedCell.row, selectedCell.col)?.classList.add('selected');
                }
                checkAllConflicts();
            }

            function updateCellNotes(row, col) {
                const cellElement = getCellElement(row, col);
                if (!cellElement) return;
                const notesGrid = cellElement.querySelector('.notes-grid');
                if (!notesGrid) return;

                const allNoteCells = notesGrid.querySelectorAll('.note-cell');

                if (currentGrid[row][col] !== 0) { // Cell has a value
                    notesGrid.style.display = 'none';
                    allNoteCells.forEach(nc => nc.classList.remove('visible', 'hidden-single'));
                    return;
                } else { // Cell is empty
                    notesGrid.style.display = 'grid'; // Show notes grid container
                    if (!autoNotesEnabled) { // Auto notes are OFF
                        allNoteCells.forEach(nc => nc.classList.remove('visible', 'hidden-single'));
                        return; // Don't calculate or show any notes
                    }
                }

                // Auto notes are ON and cell is empty
                const possible = getPossibleNumbers(currentGrid, row, col);
                for (let n = 1; n <= SIZE; n++) {
                    const noteCell = notesGrid.querySelector(`.note-cell[data-note='${n}']`);
                    if (!noteCell) continue;
                    noteCell.classList.toggle('visible', possible.includes(n));
                    // Reset hidden single, will be re-applied by updateHiddenSingleNotesStyling
                    noteCell.classList.remove('hidden-single');
                }
            }

            function updateAllNotes() {
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        updateCellNotes(r, c);
                    }
                }
                updateHiddenSingleNotesStyling();
            }


            function getPossibleNumbers(grid, row, col) {
                if (grid[row][col] !== 0) return [];
                let possible = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let i = 0; i < SIZE; i++) {
                    if (grid[row][i] !== 0) possible.delete(grid[row][i]);
                    if (grid[i][col] !== 0) possible.delete(grid[i][col]);
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    if (grid[boxR][boxC] !== 0) possible.delete(grid[boxR][boxC]);
                }
                return Array.from(possible);
            }


            function handleCellClick(event) {
                if (isGenerating) return;
                const cell = event.currentTarget;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                if (!isCustomMode && initialGrid[row][col] !== 0) {
                    selectCell(row, col, cell);
                    return;
                }

                if (selectedNumber !== null) {
                    placeNumberInCell(row, col, selectedNumber);
                } else {
                    selectCell(row, col, cell);
                }
            }

            function handleNumberClick(event) {
                if (isGenerating) return;
                const button = event.currentTarget;
                if (button.disabled) return;

                const number = parseInt(button.dataset.number);
                if (selectedNumber === number) {
                    clearSelection();
                    return;
                }
                selectNumber(number, button);
                if (selectedCell) {
                    if (isCustomMode || initialGrid[selectedCell.row][selectedCell.col] === 0) {
                         placeNumberInCell(selectedCell.row, selectedCell.col, number);
                    }
                }
            }

            function handleKeyDown(event) {
                if (isGenerating || !selectedCell) return;
                const { row, col } = selectedCell;
                 if (!isCustomMode && initialGrid[row][col] !== 0) {
                    if (event.key.startsWith('Arrow')) {
                         moveSelection(event.key);
                         event.preventDefault();
                    }
                    return;
                 }
                let number = null;
                if (event.key >= '1' && event.key <= '9') {
                    number = parseInt(event.key);
                } else if (event.key === 'Backspace' || event.key === 'Delete' || event.key === '0') {
                    number = 0;
                } else if (event.key.startsWith('Arrow')) {
                    moveSelection(event.key);
                    event.preventDefault();
                    return;
                }
                if (number !== null) {
                    event.preventDefault();
                    const numBtn = numberPad.querySelector(`.num-btn[data-number='${number}']`);
                    if (!isCustomMode && number !== 0 && numBtn && numBtn.disabled) {
                        return;
                    }
                    placeNumberInCell(row, col, number);
                }
            }


            function placeNumberInCell(row, col, number) {
                 if (!isCustomMode && initialGrid[row][col] !== 0) return;

                const currentValue = currentGrid[row][col];
                const newValue = (number === 0 || (number !== 0 && number === currentValue)) ? 0 : number;

                if (currentGrid[row][col] !== newValue) {
                    currentGrid[row][col] = newValue;

                    const cellElement = getCellElement(row, col);
                    const valueDiv = cellElement.querySelector('.value');
                    const notesGrid = cellElement.querySelector('.notes-grid');

                    cellElement.classList.remove('user-wrong');
                    if (newValue !== 0) {
                        valueDiv.textContent = newValue;
                        notesGrid.style.display = 'none'; // Hide notes display
                        // Clear note visibility classes if value is placed
                        notesGrid.querySelectorAll('.note-cell').forEach(nc => nc.classList.remove('visible', 'hidden-single'));
                        cellElement.classList.remove('initial');

                        if (!isCustomMode && solvedGrid.length > 0 && newValue !== solvedGrid[row][col]) {
                            cellElement.classList.add('user-wrong');
                        }
                    } else {
                        valueDiv.textContent = '';
                        notesGrid.style.display = 'grid'; // Show notes grid container
                        // updateCellNotes will handle actual note visibility based on autoNotesEnabled
                    }

                    updateNotesInAffectedCells(row, col); // This calls updateCellNotes and updateHiddenSingleNotesStyling
                    checkAllConflicts();
                    updateNumberPadState();

                    if (!isCustomMode) {
                        checkWinCondition();
                    } else {
                        statusMessage.textContent = "Custom Mode: Fill the grid.";
                    }
                }
                selectCell(row, col, getCellElement(row, col));
            }


            function getCellElement(row, col) {
                return gridElement.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            }

            function selectCell(row, col, element) {
                if (!element) return;
                clearSelectionVisually();
                selectedCell = { row, col, element };
                element.classList.add('selected');
                highlightAffectedCells(row, col);
                if (selectedNumber !== null) {
                    const numBtn = numberPad.querySelector(`.num-btn[data-number='${selectedNumber}']`);
                    if (numBtn) numBtn.classList.add('selected');
                }
            }

            function selectNumber(number, element) {
                numberPad.querySelectorAll('.num-btn').forEach(btn => btn.classList.remove('selected'));
                if (element) element.classList.add('selected');
                selectedNumber = number;
            }

            function clearSelectionVisually() {
                if (selectedCell) {
                    selectedCell.element.classList.remove('selected');
                }
                gridElement.querySelectorAll('.cell.highlight').forEach(cell => cell.classList.remove('highlight'));
                numberPad.querySelectorAll('.num-btn').forEach(btn => btn.classList.remove('selected'));
            }

            function clearSelection() {
                clearSelectionVisually();
                selectedCell = null;
                selectedNumber = null;
            }

            function highlightAffectedCells(row, col) {
                gridElement.querySelectorAll('.cell.highlight').forEach(cell => cell.classList.remove('highlight'));
                const currentVal = currentGrid[row][col];
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let i = 0; i < SIZE; i++) {
                    getCellElement(row, i)?.classList.add('highlight');
                    getCellElement(i, col)?.classList.add('highlight');
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    getCellElement(boxR, boxC)?.classList.add('highlight');
                }
                if (currentVal !== 0) {
                    for (let r = 0; r < SIZE; r++) {
                        for (let c = 0; c < SIZE; c++) {
                            if (currentGrid[r][c] === currentVal) {
                                getCellElement(r, c)?.classList.add('highlight');
                            }
                        }
                    }
                }
            }

             function updateNotesInAffectedCells(row, col) {
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                const cellsToUpdate = new Set();
                for (let i = 0; i < SIZE; i++) {
                    cellsToUpdate.add(`${row}-${i}`);
                    cellsToUpdate.add(`${i}-${col}`);
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    cellsToUpdate.add(`${boxR}-${boxC}`);
                }
                cellsToUpdate.forEach(coord => {
                    const [r, c] = coord.split('-').map(Number);
                    updateCellNotes(r, c); // This updates visibility based on autoNotesEnabled
                });
                updateHiddenSingleNotesStyling(); // Re-style hidden singles
            }


            function checkAllConflicts() {
                gridElement.querySelectorAll('.cell.conflicting').forEach(cell => cell.classList.remove('conflicting'));
                let hasRuleConflict = false;
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        const value = currentGrid[r][c];
                        if (value !== 0) {
                            if (!isValid(currentGrid, r, c, value)) {
                                markRuleConflict(r, c, value);
                                hasRuleConflict = true;
                            }
                        }
                    }
                }
                return hasRuleConflict;
            }

            function markRuleConflict(row, col, num) {
                const cellElement = getCellElement(row, col);
                if (!isValid(currentGrid, row, col, num)) {
                    cellElement?.classList.add('conflicting');
                }
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for(let i=0; i<SIZE; i++) {
                    if (i !== col && currentGrid[row][i] === num) getCellElement(row, i)?.classList.add('conflicting');
                    if (i !== row && currentGrid[i][col] === num) getCellElement(i, col)?.classList.add('conflicting');
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    if ((boxR !== row || boxC !== col) && currentGrid[boxR][boxC] === num) {
                        getCellElement(boxR, boxC)?.classList.add('conflicting');
                    }
                }
            }


            function checkWinCondition() {
                 if (isCustomMode) return false;
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        if (currentGrid[r][c] === 0 || (solvedGrid.length > 0 && currentGrid[r][c] !== solvedGrid[r][c])) {
                            statusMessage.textContent = "";
                            return false;
                        }
                    }
                }
                statusMessage.textContent = "Congratulations! You solved it!";
                clearSelection();
                return true;
            }

            function countNumberOnGrid(number) {
                let count = 0;
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        if (currentGrid[r][c] === number) count++;
                    }
                }
                return count;
            }

            function updateNumberPadState() {
                for (let n = 1; n <= SIZE; n++) {
                    const count = countNumberOnGrid(n);
                    const button = numberPad.querySelector(`.num-btn[data-number='${n}']`);
                    if (button) {
                        button.disabled = !isCustomMode && (count >= SIZE);
                    }
                }
                const eraseButton = numberPad.querySelector('.num-btn.erase');
                if(eraseButton) eraseButton.disabled = false;
            }

            function moveSelection(key) {
                if (!selectedCell) return;
                let { row, col } = selectedCell;
                switch (key) {
                    case 'ArrowUp':    row = Math.max(0, row - 1); break;
                    case 'ArrowDown':  row = Math.min(SIZE - 1, row + 1); break;
                    case 'ArrowLeft':  col = Math.max(0, col - 1); break;
                    case 'ArrowRight': col = Math.min(SIZE - 1, col + 1); break;
                }
                const newCellElement = getCellElement(row, col);
                if (newCellElement) {
                    selectCell(row, col, newCellElement);
                }
            }


             function checkHiddenSingle(row, col, num) {
                let foundInRowElsewhere = false;
                for (let cCheck = 0; cCheck < SIZE; cCheck++) {
                    if (cCheck !== col && currentGrid[row][cCheck] === 0) {
                        if (getPossibleNumbers(currentGrid, row, cCheck).includes(num)) {
                            foundInRowElsewhere = true;
                            break;
                        }
                    }
                }
                if (!foundInRowElsewhere && getPossibleNumbers(currentGrid, row, col).includes(num)) return true;

                let foundInColElsewhere = false;
                for (let rCheck = 0; rCheck < SIZE; rCheck++) {
                    if (rCheck !== row && currentGrid[rCheck][col] === 0) {
                        if (getPossibleNumbers(currentGrid, rCheck, col).includes(num)) {
                            foundInColElsewhere = true;
                            break;
                        }
                    }
                }
                if (!foundInColElsewhere && getPossibleNumbers(currentGrid, row, col).includes(num)) return true;

                let foundInBlockElsewhere = false;
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let rCheck = startRow; rCheck < startRow + BOX_SIZE; rCheck++) {
                    for (let cCheck = startCol; cCheck < startCol + BOX_SIZE; cCheck++) {
                        if ((rCheck !== row || cCheck !== col) && currentGrid[rCheck][cCheck] === 0) {
                            if (getPossibleNumbers(currentGrid, rCheck, cCheck).includes(num)) {
                                foundInBlockElsewhere = true;
                                break;
                            }
                        }
                    }
                    if (foundInBlockElsewhere) break;
                }
                 if (!foundInBlockElsewhere && getPossibleNumbers(currentGrid, row, col).includes(num)) return true;
                return false;
            }

            function updateHiddenSingleNotesStyling() {
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        const cellElement = getCellElement(r, c);
                        if (!cellElement) continue;

                        const notesGrid = cellElement.querySelector('.notes-grid');
                        if (!notesGrid) continue;

                        const allNoteCellsInGrid = notesGrid.querySelectorAll('.note-cell');

                        if (currentGrid[r][c] !== 0) { // Cell has a value, ensure no bolding
                            allNoteCellsInGrid.forEach(nc => nc.classList.remove('hidden-single'));
                            continue;
                        }

                        // Cell is empty. Apply styling based on toggles.
                        if (!autoNotesEnabled) { // If auto notes are off, no notes are visible, so no bolding.
                            allNoteCellsInGrid.forEach(nc => nc.classList.remove('hidden-single'));
                            continue;
                        }

                        // Auto notes are ON.
                        for (let n = 1; n <= SIZE; n++) {
                            const noteCell = notesGrid.querySelector(`.note-cell[data-note='${n}']`);
                            if (!noteCell) continue;

                            // Remove bolding if bolding is disabled OR if the note itself is not 'visible'
                            if (!boldHiddenSinglesEnabled || !noteCell.classList.contains('visible')) {
                                noteCell.classList.remove('hidden-single');
                            } else {
                                // Bolding is ON and this note is 'visible'. Check if it's a hidden single.
                                if (checkHiddenSingle(r, c, n)) {
                                    noteCell.classList.add('hidden-single');
                                } else {
                                    noteCell.classList.remove('hidden-single');
                                }
                            }
                        }
                    }
                }
            }


            // --- Initialization ---
            autoNotesToggle.checked = autoNotesEnabled;
            boldHiddenSinglesToggle.checked = boldHiddenSinglesEnabled;

            autoNotesToggle.addEventListener('change', () => {
                autoNotesEnabled = autoNotesToggle.checked;
                updateAllNotes(); // Recalculate/hide all notes and update bolding
            });

            boldHiddenSinglesToggle.addEventListener('change', () => {
                boldHiddenSinglesEnabled = boldHiddenSinglesToggle.checked;
                updateHiddenSingleNotesStyling(); // Just update bold styling
            });


            createGridDOM();
            numberPad.querySelectorAll('.num-btn').forEach(button => {
                button.addEventListener('click', handleNumberClick);
            });
            newGameBtn.addEventListener('click', setupNewGame);
            difficultySelect.addEventListener('change', setupNewGame);
            document.addEventListener('keydown', handleKeyDown);

            setupNewGame();
            console.log("Sudoku Initialized with Toggles.");
        });
    </script>
</body>
</html>