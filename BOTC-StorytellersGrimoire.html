<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOCT Grimoire</title>
    <style>
        /* General Setup */
        :root {
            --bg-dark: #111827;
            --bg-med: #1f2937;
            --bg-light: #374151;
            --text-light: #e5e7eb;
            --text-med: #9ca3af;
            --border-color: #4b5563;
            --townsfolk: #059669;
            --outsider: #0284c7;
            --minion: #ca8a04;
            --demon: #be123c;
            --red: #be123c;
            --poison: #84cc16; /* Lime green for poison */
            --yellow: #ca8a04;
        }
        body {
            background-color: var(--bg-dark);
            color: var(--text-light);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 1.5rem;
        }
        body.dragging-token {
             cursor: grabbing;
        }

        /* Layout */
        .container {
            max-width: 1400px;
            margin: auto;
        }
        .main-layout {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }
        @media (min-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr 2.5fr 1fr;
            }
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 2rem;
        }
        header h1 {
            font-size: 3rem;
            font-weight: 800;
            margin: 0;
        }
        header p {
            color: var(--text-med);
            font-size: 1.125rem;
        }

        /* Panels */
        .panel {
            background-color: var(--bg-med);
            border-radius: 0.75rem;
            padding: 1rem;
        }
        #center-panel {
            position: relative; /* For SVG overlay */
        }
        #right-column {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .panel-title {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 1rem;
            padding: 0.5rem 0;
        }

        /* Role Library */
        #role-library-container {
            max-height: 85vh;
            overflow-y: auto;
        }
        .role-group h3 {
            font-size: 1.25rem;
            font-weight: bold;
            padding: 0.5rem;
            border-radius: 0.5rem 0.5rem 0 0;
            margin: 1rem 0 0 0;
            color: white;
        }
        .role-group-body {
            padding: 0.5rem;
            border: 2px solid;
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
        }
        .role-card-small {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            margin-bottom: 0.25rem;
            cursor: grab;
            background-color: var(--bg-light);
        }
        .role-card-small:active { cursor: grabbing; }

        /* Color Themes */
        .townsfolk-header { background-color: var(--townsfolk); }
        .townsfolk-body { border-color: var(--townsfolk); }
        .townsfolk-card { border-color: var(--townsfolk); }
        .outsider-header { background-color: var(--outsider); }
        .outsider-body { border-color: var(--outsider); }
        .outsider-card { border-color: var(--outsider); }
        .minion-header { background-color: var(--minion); }
        .minion-body { border-color: var(--minion); }
        .minion-card { border-color: var(--minion); }
        .demon-header { background-color: var(--demon); }
        .demon-body { border-color: var(--demon); }
        .demon-card { border-color: var(--demon); }

        /* Player Table */
        .player-rows-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
            padding: 1rem;
        }
        .player-spot, .bluff-spot {
            width: 192px; /* Card width */
            transition: box-shadow 0.2s;
            position: relative;
        }
        .player-spot.drag-over {
            box-shadow: 0 0 20px 5px var(--townsfolk);
            border-radius: 0.75rem;
        }
        .player-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .player-name-input {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 2px solid var(--border-color);
            color: var(--text-light);
            font-size: 1.125rem;
            font-weight: bold;
            text-align: center;
            padding: 0.25rem;
            box-sizing: border-box;
            flex-grow: 1;
        }
        .player-name-input:focus {
            outline: none;
            border-bottom-color: var(--townsfolk);
        }
        .player-card {
            width: 192px;
            height: 256px;
            border: 2px solid var(--border-color);
            background-color: var(--bg-dark);
            border-radius: 0.75rem;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-sizing: border-box;
            position: relative;
        }
        .player-card.dead {
            filter: grayscale(1) opacity(0.5);
            border-color: var(--red);
        }
        .player-card-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-med);
            height: 100%;
        }
        .player-card-header {
            font-size: 1.125rem;
            font-weight: 800;
            text-align: center;
            border-bottom: 2px solid;
            padding-bottom: 0.25rem;
            margin-bottom: 0.5rem;
        }
        .player-card-header .thinker-indicator {
            font-size: 0.8rem;
            font-style: italic;
            color: var(--text-med);
        }
        .player-card-ability {
            font-size: 0.875rem;
            flex-grow: 1;
            overflow: hidden;
        }
        .player-card-type {
            font-size: 0.75rem;
            font-weight: 600;
            text-align: center;
            text-transform: uppercase;
        }

        /* Card Tokens */
        .source-tokens-container {
            display: flex;
            gap: 0.5rem;
            height: 28px;
            justify-content: center;
            align-items: center;
            margin-top: 0.5rem;
        }
        .card-token {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: grab;
            background-color: var(--bg-light);
            border: 1px solid var(--border-color);
            transition: all 0.2s;
            box-sizing: border-box;
        }
        .card-token:active {
            cursor: grabbing;
        }
        .card-token.used {
            opacity: 0.4;
        }
        .card-token.received-token {
             position: absolute;
             width: 24px;
             height: 24px;
             font-size: 14px;
             z-index: 12;
             cursor: pointer;
        }


        /* Controls */
        #table-controls {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        #table-controls label { font-weight: bold; margin-right: 0.5rem; }
        #table-controls select, #table-controls button {
            background-color: var(--bg-light);
            color: var(--text-light);
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
            font-size: 1rem;
        }
        #table-controls button { cursor: pointer; background-color: var(--red); }
        #table-controls button:hover { opacity: 0.9; }
        
        /* Night Order & Bluffs */
        #night-order-panel, #demon-bluffs-panel, #role-counts-panel {
             height: fit-content;
        }
        .night-order-list {
            list-style-type: decimal;
            list-style-position: inside;
            padding-left: 0;
            margin: 0;
        }
        .night-order-list li {
            margin-bottom: 0.25rem;
        }
        .night-order-list span {
            color: var(--text-med);
        }
        .night-order-section h3 {
            font-size: 1.125rem;
            font-weight: 600;
            border-bottom: 2px solid var(--townsfolk);
            padding-bottom: 0.25rem;
            margin: 1rem 0 0.5rem 0;
        }

        /* Notes & Visual Links Feature */
        .notes-btn, .death-toggle-btn {
            position: absolute;
            width: 28px;
            height: 28px;
            background-color: rgba(0,0,0,0.4);
            border-radius: 50%;
            border: 1px solid var(--border-color);
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; /* For Emojis */
            color: var(--text-med);
        }
        .notes-btn { 
            top: 8px; 
            right: 8px;
            font-size: 16px; 
        }
        .notes-btn.has-notes { 
            color: var(--townsfolk); 
        }
        .death-toggle-btn {
            position: relative;
            width: 24px;
            height: 24px;
            font-size: 16px;
        }
        .death-toggle-btn.is-dead {
            background-color: var(--red);
            border-color: var(--red);
            color: white;
        }

        #notes-modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 99;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #notes-modal {
            background-color: var(--bg-med);
            padding: 2rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 500px;
            border: 1px solid var(--border-color);
        }
        #notes-modal h2 {
            margin-top: 0;
            text-align: center;
        }
        #notes-modal-textarea {
            width: 100%;
            height: 150px;
            background-color: var(--bg-dark);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            padding: 0.5rem;
            border-radius: 0.375rem;
            box-sizing: border-box;
            font-size: 1rem;
        }
        .notes-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1rem;
        }
        .hidden {
            display: none !important;
        }
        #visual-links-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            overflow: visible;
        }
        
        .linker-line {
             stroke-width: 3;
        }

        /* Role Counts */
        .role-count-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            text-align: center;
        }
        .role-count-grid div {
            padding: 0.5rem;
            border-radius: 0.375rem;
        }
        .role-count-grid div[style*="--townsfolk"] { background-color: var(--townsfolk); }
        .role-count-grid div[style*="--outsider"] { background-color: var(--outsider); }
        .role-count-grid div[style*="--minion"] { background-color: var(--minion); }
        .role-count-grid div[style*="--demon"] { background-color: var(--demon); }
        
        .role-count-value {
            font-weight: bold;
            padding: 0 0.25rem;
        }
        .count-ok { color: lightgreen; }
        .count-under { color: yellow; }
        .count-over { color: #ff8a8a; }

    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>Storyteller's Grimoire</h1>
            <p>Create scripts and run your game of Blood on the Clocktower</p>
        </header>

        <main id="app-container" class="main-layout">
            <div id="role-library-container" class="panel">
                <h2 class="panel-title">Role Library</h2>
                <div id="role-library-content"></div>
            </div>

            <div id="center-panel">
                <div id="table-controls" class="panel"></div>
                <div id="table-container" class="player-rows-container"></div>
                <svg id="visual-links-svg">
                    <defs></defs>
                </svg>
            </div>

            <div id="right-column">
                <div id="role-counts-panel" class="panel">
                    <h2 class="panel-title">Role Counts</h2>
                    <div id="role-counts-content"></div>
                </div>
                <div id="night-order-panel" class="panel">
                    <h2 class="panel-title">Night Order</h2>
                    <div id="night-order-content"></div>
                </div>
                <div id="demon-bluffs-panel" class="panel">
                    <h2 class="panel-title">Demon Bluffs</h2>
                    <div id="demon-bluffs-content" class="player-rows-container"></div>
                </div>
            </div>
        </main>
    </div>

    <div id="notes-modal-backdrop" class="hidden">
        <div id="notes-modal">
            <h2 id="notes-modal-title"></h2>
            <textarea id="notes-modal-textarea"></textarea>
            <div class="notes-modal-actions">
                <button id="notes-modal-cancel">Cancel</button>
                <button id="notes-modal-save" class="townsfolk-header">Save</button>
            </div>
        </div>
    </div>

    <script>
        // --- DATA STORE ---
        const ROLES = {
            // Townsfolk
            acrobat: { id: 'acrobat', name: 'Acrobat', type: 'Townsfolk', otherNight: 5, ability: "Each night*, choose a player: if they are or become drunk or poisoned tonight, you die." },
            alchemist: { id: 'alchemist', name: 'Alchemist', type: 'Townsfolk', ability: "You have a Minion ability. When using this, the Storyteller may prompt you to choose differently." },
            alsaahir: { id: 'alsaahir', name: 'Alsaahir', type: 'Townsfolk', otherNight: 6, ability: "Each day, if you publicly guess which players are Minion(s) and which are Demon(s), good wins." },
            amnesiac: { id: 'amnesiac', name: 'Amnesiac', type: 'Townsfolk', otherNight: 6, ability: "You do not know what your ability is. Each day, privately guess what it is: you learn how accurate you are." },
            artist: { id: 'artist', name: 'Artist', type: 'Townsfolk', otherNight: 9, ability: "Once per game, during the day, privately ask the Storyteller any yes/no question." },
            atheist: { id: 'atheist', name: 'Atheist', type: 'Townsfolk', ability: "The Storyteller can break the game rules, and if executed, good wins, even if you are dead. [No evil characters]" },
            balloonist: { id: 'balloonist', name: 'Balloonist', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, you learn a player of a different character type than last night. [+0 or +1 Outsider]" },
            banshee: { id: 'banshee', name: 'Banshee', type: 'Townsfolk', ability: "If the Demon kills you, all players learn this. From now on, you may nominate twice per day and vote twice per nomination." },
            bounty_hunter: { id: 'bounty_hunter', name: 'Bounty Hunter', type: 'Townsfolk', firstNight: 1, ability: "You start knowing 1 evil player. If the player you know dies, you learn another evil player tonight. [1 Townsfolk is evil]" },
            cannibal: { id: 'cannibal', name: 'Cannibal', type: 'Townsfolk', ability: "You have the ability of the recently killed executee. If they are evil, you are poisoned until a good player dies by execution." },            
            chambermaid: { id: 'chambermaid', name: 'Chambermaid', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, choose 2 alive players (not yourself): you learn how many woke tonight due to their ability." },
            chef: { id: 'chef', name: 'Chef', type: 'Townsfolk', firstNight: 1, ability: "You start knowing how many pairs of evil players there are." },
            choirboy: { id: 'choirboy', name: 'Choirboy', type: 'Townsfolk', ability: "If the Demon kills the King, you learn which player is the Demon. [+the King]" },
            clockmaker: { id: 'clockmaker', name: 'Clockmaker', type: 'Townsfolk', firstNight: 1, ability: "You start knowing how many steps from the Demon to its nearest Minion." },
            courtier: { id: 'courtier', name: 'Courtier', type: 'Townsfolk', firstNight: 7, otherNight: 7, ability: "Once per game, at night, choose a character: they are drunk for 3 nights & 3 days." },
            cult_leader: { id: 'cult_leader', name: 'Cult Leader', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, you become the alignment of an alive neighbor. If all good players choose to join your cult, your team wins." },
            dreamer: { id: 'dreamer', name: 'Dreamer', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, choose a player: you learn 1 good and 1 evil character, 1 of which is correct." },
            empath: { id: 'empath', name: 'Empath', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, you learn how many of your 2 alive neighbors are evil." },
            engineer: { id: 'engineer', name: 'Engineer', type: 'Townsfolk', firstNight: 7, otherNight: 7, ability: "Once per game, at night, choose which Minions or which Demon is in play." },
            exorcist: { id: 'exorcist', name: 'Exorcist', type: 'Townsfolk', otherNight: 5, ability: "Each night*, choose a player (different to last night): the Demon, if chosen, learns who you are then doesn't wake tonight." },
            farmer: { id: 'farmer', name: 'Farmer', type: 'Townsfolk', ability: "When you die at night, an alive good player becomes a Farmer." },
            fisherman: { id: 'fisherman', name: 'Fisherman', type: 'Townsfolk', otherNight: 9, ability: "Once per game, during the day, visit the Storyteller for some advice to help your team win." },
            flowergirl: { id: 'flowergirl', name: 'Flowergirl', type: 'Townsfolk', otherNight: 5, ability: "Each night*, you learn if a Demon voted today." },
            fool: { id: 'fool', name: 'Fool', type: 'Townsfolk', ability: "The first time you die, you don't." },
            fortune_teller: { id: 'fortune_teller', name: 'Fortune Teller', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, choose 2 players: you learn if either is a Demon. There is a good player that registers as a Demon to you." },
            gambler: { id: 'gambler', name: 'Gambler', type: 'Townsfolk', otherNight: 5, ability: "Each night*, choose a player & guess their character: if you guess wrong, you die." },
            general: { id: 'general', name: 'General', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, you learn which alignment the Storyteller believes is winning: good, evil, or neither." },
            gossip: { id: 'gossip', name: 'Gossip', type: 'Townsfolk', otherNight: 6, ability: "Each day, you may make a public statement. Tonight, if it was true, a player dies." },
            grandmother: { id: 'grandmother', name: 'Grandmother', type: 'Townsfolk', firstNight: 1, ability: "You start knowing a good player & their character. If the Demon kills them, you die too." },
            high_priestess: { id: 'high_priestess', name: 'High Priestess', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, learn which player the Storyteller believes you should talk to most." },
            huntsman: { id: 'huntsman', name: 'Huntsman', type: 'Townsfolk', firstNight: 7, otherNight: 7, ability: "Once per game, at night, choose a living player: the Damsel, if chosen, becomes a not-in-play Townsfolk. [+the Damsel]" },
            innkeeper: { id: 'innkeeper', name: 'Innkeeper', type: 'Townsfolk', otherNight: 5, ability: "Each night*, choose 2 players: they can't die tonight, but 1 is drunk until dusk." },
            investigator: { id: 'investigator', name: 'Investigator', type: 'Townsfolk', firstNight: 1, ability: "You start knowing that 1 of 2 players is a particular Minion." },            
            juggler: { id: 'juggler', name: 'Juggler', type: 'Townsfolk', firstNight: 12, ability: "On your 1st day, publicly guess up to 5 players' characters. That night, you learn how many you got correct." },
            king: { id: 'king', name: 'King', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, if the dead equal or outnumber the living, you learn 1 alive character. The Demon knows you are the King." },
            knight: { id: 'knight', name: 'Knight', type: 'Townsfolk', firstNight: 1, ability: "You start knowing 2 players that are not the Demon." },
            librarian: { id: 'librarian', name: 'Librarian', type: 'Townsfolk', firstNight: 1, ability: "You start knowing that 1 of 2 players is a particular Outsider. (Or that zero are in play.)" },
            lycanthrope: { id: 'lycanthrope', name: 'Lycanthrope', type: 'Townsfolk', otherNight: 5, ability: "Each night*, choose an alive player. If good, they die & the Demon doesn’t kill tonight. One good player registers as evil." },
            magician: { id: 'magician', name: 'Magician', type: 'Townsfolk', ability: "The Demon thinks you are a Minion. Minions think you are a Demon." },
            mathematician: { id: 'mathematician', name: 'Mathematician', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, you learn how many players' abilities worked abnormally (since dawn) due to another character's ability." },
            mayor: { id: 'mayor', name: 'Mayor', type: 'Townsfolk', ability: "If only 3 players live & no execution occurs, your team wins. If you die at night, another player might die instead." },
            minstrel: { id: 'minstrel', name: 'Minstrel', type: 'Townsfolk', ability: "When a Minion dies by execution, all other players (except Travellers) are drunk until dusk tomorrow." },
            monk: { id: 'monk', name: 'Monk', type: 'Townsfolk', otherNight: 5, ability: "Each night*, choose a player (not yourself): they are safe from the Demon tonight." },
            nightwatchman: { id: 'nightwatchman', name: 'Nightwatchman', type: 'Townsfolk', firstNight: 7, otherNight: 7, ability: "Once per game, at night, choose a player: they learn you are the Nightwatchman." },
            noble: { id: 'noble', name: 'Noble', type: 'Townsfolk', firstNight: 1, ability: "You start knowing 3 players, and only 1 of which is evil." },
            oracle: { id: 'oracle', name: 'Oracle', type: 'Townsfolk', otherNight: 5, ability: "Each night*, you learn how many dead players are evil." },
            pacifist: { id: 'pacifist', name: 'Pacifist', type: 'Townsfolk', ability: "Executed good players might not die." },
            philosopher: { id: 'philosopher', name: 'Philosopher', type: 'Townsfolk', firstNight: 7, otherNight: 7, ability: "Once per game, at night, choose a good character: gain that ability. If this character is in play, they are drunk." },
            pixie: { id: 'pixie', name: 'Pixie', type: 'Townsfolk', firstNight: 1, ability: "You start knowing 1 in-play Townsfolk. If you were mad that you were this character, you gain their ability when they die." },
            poppy_grower: { id: 'poppy_grower', name: 'Poppy Grower', type: 'Townsfolk', ability: "Minions & Demons do not know each other. If you die, they learn who each other are that night." },
            preacher: { id: 'preacher', name: 'Preacher', type: 'Townsfolk', firstNight: 4, otherNight: 4, ability: "Each night, choose a player: a Minion, if chosen, learns this. All chosen Minions have no ability." },
            princess: { id: 'princess', name: 'Princess', type: 'Townsfolk', firstNight: 12, ability: "On your 1st day, if you nominated & executed a player, the Demon doesn’t kill tonight." },
            professor: { id: 'professor', name: 'Professor', type: 'Townsfolk', otherNight: 8, ability: "Once per game, at night*, choose a dead player: if they are a Townsfolk, they are resurrected." },

            ravenkeeper: { id: 'ravenkeeper', name: 'Ravenkeeper', type: 'Townsfolk', ability: "If you die at night, you are woken to choose a player: you learn their character." },
            sage: { id: 'sage', name: 'Sage', type: 'Townsfolk', ability: "If you are killed by the Demon, you learn that 1 of 2 players is the Demon." },
            sailor: { id: 'sailor', name: 'Sailor', type: 'Townsfolk', otherNight: 5, ability: "Each night*, choose an alive player: either you or they are drunk tonight. You can't die." },
            savant: { id: 'savant', name: 'Savant', type: 'Townsfolk', ability: "Each day, choose 2 players: you learn if they are the same alignment. Or, choose 1 player: you learn if they are good." },
            seamstress: { id: 'seamstress', name: 'Seamstress', type: 'Townsfolk', firstNight: 2, ability: "On your 1st night, you learn if any 2 players are the same alignment." },
            shugenja: { id: 'shugenja', name: 'Shugenja', type: 'Townsfolk', ability: "You start knowing if your closest evil neighbor is to your left or right. If you are 'mad' about this, you are the neighbor of a new player each day." },
            slayer: { id: 'slayer', name: 'Slayer', type: 'Townsfolk', ability: "Once per game, during the day, you may publicly choose a player: if they are the Demon, they die." },
            snake_charmer: { id: 'snake_charmer', name: 'Snake Charmer', type: 'Townsfolk', otherNight: 4, ability: "Each night, choose an alive player: if they are the Demon, you both die. A Minion becomes the new Demon." },
            soldier: { id: 'soldier', name: 'Soldier', type: 'Townsfolk', ability: "You are safe from the Demon." },
            steward: { id: 'steward', name: 'Steward', type: 'Townsfolk', firstNight: 1, ability: "You start knowing 1 of 2 players is a particular good character." },
            tea_lady: { id: 'tea_lady', name: 'Tea Lady', type: 'Townsfolk', ability: "If both your alive neighbors are good, you can't die." },
            town_crier: { id: 'town_crier', name: 'Town Crier', type: 'Townsfolk', firstNight: 2, otherNight: 1, ability: "Each night, you learn if a Minion nominated today." },
            undertaker: { id: 'undertaker', name: 'Undertaker', type: 'Townsfolk', otherNight: 3, ability: "Each night*, you learn which character died by execution today." },
            village_idiot: { id: 'village_idiot', name: 'Village Idiot', type: 'Townsfolk', ability: "Each night, choose a player: you are drunk and you learn their alignment. If you choose an evil player, you might be 'mad' about being the Village Idiot." },
            virgin: { id: 'virgin', name: 'Virgin', type: 'Townsfolk', ability: "The first time you are nominated, if the nominator is a Townsfolk, they are executed immediately." },
            washerwoman: { id: 'washerwoman', name: 'Washerwoman', type: 'Townsfolk', firstNight: 1, ability: "You start knowing that 1 of 2 players is a particular Townsfolk." },
            // Traveller townsfolk
            apprentice: { id: 'apprentice', name: 'Apprentice', type: 'Townsfolk', firstNight: 8, ability: "On your 1st night, you learn your Townsfolk or Minion ability. If you are a Minion, you are also told who your Demon is." },
            barista: { id: 'barista', name: 'Barista', type: 'Townsfolk', ability: "Once per game, at night, a player of your choice gets a powerful ability. The Storyteller chooses what it is." },
            beggar: { id: 'beggar', name: 'Beggar', type: 'Townsfolk', ability: "You are sober & healthy. You may not be chosen by the Demon at night. The Storyteller may break this rule." },
            bishop: { id: 'bishop', name: 'Bishop', type: 'Townsfolk', otherNight: 6, ability: "Each night, choose a player. The Demon can't attack them, but you don't know if your power worked." },
            butcher: { id: 'butcher', name: 'Butcher', type: 'Townsfolk', ability: "Each day, you may publicly choose a player. The Storyteller may execute them." },
            gunslinger: { id: 'gunslinger', name: 'Gunslinger', type: 'Townsfolk', otherNight: 7, ability: "Each night, choose a player: they die. If they are a Minion or Demon, you learn their team." },
            harlot: { id: 'harlot', name: 'Harlot', type: 'Townsfolk', otherNight: 3, ability: "Each night, choose a player: you learn their character. If they are the Demon, you both die." },
            judge: { id: 'judge', name: 'Judge', type: 'Townsfolk', ability: "Once per game, during the day, you may choose a player. The Storyteller publicly declares their alignment." },
            matron: { id: 'matron', name: 'Matron', type: 'Townsfolk', ability: "You start knowing which good character is in play." },
            thief: { id: 'thief', name: 'Thief', type: 'Townsfolk', otherNight: 4, ability: "Each night*, choose a player: you learn their character. If they are evil, you might die." },
            // Outsiders
            barber: { id: 'barber', name: 'Barber', type: 'Outsider', ability: "Once per game, at night, choose 2 players: they swap characters. The new evil player is drunk." },
            butler: { id: 'butler', name: 'Butler', type: 'Outsider', firstNight: 5, otherNight: 4, ability: "Each night, choose a living player: tomorrow, you may only vote if they vote." },
            damsel: { id: 'damsel', name: 'Damsel', type: 'Outsider', ability: "All Minions know who you are. The first time a Minion tries to nominate you, they are executed instead." },
            drunk: { id: 'drunk', name: 'Drunk', type: 'Outsider', ability: "You do not know you are the Drunk. You think you are a Townsfolk. You have no ability, but the Storyteller pretends you do." },
            golem: { id: 'golem', name: 'Golem', type: 'Outsider', ability: "Each day, you may nominate. If you do, you can't be the only one to vote for them, or you die." },
            goon: { id: 'goon', name: 'Goon', type: 'Outsider', ability: "If you are executed, the player who nominated you becomes drunk that night and the next day. Each night, you are drunk if your neighbor was executed today." },
            hatter: { id: 'hatter', name: 'Hatter', type: 'Outsider', ability: "If you die, a good player is 'mad' that they are a character you chose, or a new character is added to the Grimoire." },
            heretic: { id: 'heretic', name: 'Heretic', type: 'Outsider', ability: "If you are executed, your team loses." },
            hermit: { id: 'hermit', name: 'Hermit', type: 'Outsider', ability: "You might not die at night. If you are the only one to vote for a player, they die. If you are 'mad' that you are the Hermit, you might register as evil." },
            klutz: { id: 'klutz', name: 'Klutz', type: 'Outsider', ability: "The first time you learn you are the Klutz, you must publicly choose an evil player. If you are wrong, you die." },
            lunatic: { id: 'lunatic', name: 'Lunatic', type: 'Outsider', firstNight: 9, otherNight: 8, ability: "You think you are a Demon, but you are not. The Demon knows who you are and what character you think you are." },
            moonchild: { id: 'moonchild', name: 'Moonchild', type: 'Outsider', ability: "When you learn that you are the Moonchild, you must publicly choose a player. Tonight, if they are good, they die." },
            mutant: { id: 'mutant', name: 'Mutant', type: 'Outsider', ability: "If you are 'mad' about being the Mutant, you may choose to die. If you do, your team loses." },
            ogre: { id: 'ogre', name: 'Ogre', type: 'Outsider', ability: "You may have a neighbor who is evil. They do not know who you are. Each night, you might be the Demon's choice." },
            plague_doctor: { id: 'plague_doctor', name: 'Plague Doctor', type: 'Outsider', ability: "The first time a player dies, they do not die. That night, I choose a player: they die." },
            politician: { id: 'politician', name: 'Politician', type: 'Outsider', ability: "If you are the only player to vote for a player, your vote counts as 3. If you are 'mad' about this, you can't be executed." },
            puzzlemaster: { id: 'puzzlemaster', name: 'Puzzlemaster', type: 'Outsider', ability: "If you die, a good player receives secret information. They may not share it. The Storyteller may lie to them once." },
            recluse: { id: 'recluse', name: 'Recluse', type: 'Outsider', ability: "You might register as evil, even to yourself at night." },
            saint: { id: 'saint', name: 'Saint', type: 'Outsider', ability: "If you die by execution, your team loses." },
            snitch: { id: 'snitch', name: 'Snitch', type: 'Outsider', firstNight: 8, otherNight: 7, ability: "Each night, you learn 3 characters that are not in play." },
            sweetheart: { id: 'sweetheart', name: 'Sweetheart', type: 'Outsider', ability: "When you die, one player becomes drunk." },
            tinker: { id: 'tinker', name: 'Tinker', type: 'Outsider', otherNight: 9, ability: "Once per game, at night, you might die." },
            zealot: { id: 'zealot', name: 'Zealot', type: 'Outsider', otherNight: 8, ability: "Each night*, choose a player: they die. If your 2 alive neighbors are both good, you can only choose one of them." },
            // Traveller outsiders            
            bureaucrat: { id: 'bureaucrat', name: 'Bureaucrat', type: 'Outsider', otherNight: 1, ability: "Each night, choose a player: a 'red tape' token is placed on them. Players with 'red tape' cannot vote. The token is removed after they are nominated." },
            deviant: { id: 'deviant', name: 'Deviant', type: 'Outsider', ability: "If you are 'mad' that you are a good character, you might be executed." },
            gnome: { id: 'gnome', name: 'Gnome', type: 'Outsider', firstNight: 2, otherNight: 2, ability: "Each night, you learn a statement that is true. All other players learn a statement that is false." },
            scapegoat: { id: 'scapegoat', name: 'Scapegoat', type: 'Outsider', ability: "If a player is executed for a crime they did not commit, you might be executed instead." },
            // Minions
            assassin: { id: 'assassin', name: 'Assassin', type: 'Minion', ability: "Once per game, at night*, choose a player: they die, even if they are protected." },
            baron: { id: 'baron', name: 'Baron', type: 'Minion', firstNight: 7, ability: "There are extra Outsiders in play. [+2 Outsiders]" },
            boffin: { id: 'boffin', name: 'Boffin', type: 'Minion', firstNight: 1, otherNight: 1, ability: "Each night, choose a good player: you learn their character. Or, choose an evil player: you learn that they are evil." },
            boomdandy: { id: 'boomdandy', name: 'Boomdandy', type: 'Minion', ability: "If you are executed, all players (including you) are drunk for the rest of the game. The Demon may choose to kill 3 players tonight." },
            cerenovus: { id: 'cerenovus', name: 'Cerenovus', type: 'Minion', firstNight: 8, otherNight: 6, ability: "Each night, choose a player & a statement. They are 'mad' about this statement tomorrow, or you are drunk." },
            devil_s_advocate: { id: 'devil_s_advocate', name: 'Devil\'s Advocate', type: 'Minion', ability: "The player you chose to protect last night cannot be executed today. You may not choose to protect yourself." },
            evil_twin: { id: 'evil_twin', name: 'Evil Twin', type: 'Minion', ability: "You and a good player are 'twins'. If the good 'twin' is executed, you become that good character." },
            fearmonger: { id: 'fearmonger', name: 'Fearmonger', type: 'Minion', ability: "Each night, choose a player: if you nominate them tomorrow & they are executed, their team loses. If they are not executed, you might die." },
            goblin: { id: 'goblin', name: 'Goblin', type: 'Minion', ability: "If you are executed, your team wins." },
            godfather: { id: 'godfather', name: 'Godfather', type: 'Minion', firstNight: 2, ability: "You start knowing which Outsiders are in play. If an Outsider is executed, you may choose to kill a player tonight." },
            harpy: { id: 'harpy', name: 'Harpy', type: 'Minion', otherNight: 5, ability: "Each night*, choose 2 players: the 1st chosen player's vote counts as -1 tomorrow. The 2nd chosen player must vote the same way as the 1st." },
            marionette: { id: 'marionette', name: 'Marionette', type: 'Minion', ability: "You think you are a good character, but you are not. The Demon knows who you are." },
            mastermind: { id: 'mastermind', name: 'Mastermind', type: 'Minion', ability: "If the Demon dies by execution, play continues for 1 more day. If a player is then executed, their team loses." },
            mezepheles: { id: 'mezepheles', name: 'Mezepheles', type: 'Minion', firstNight: 1, ability: "You start knowing a secret keyword. Each night*, choose a player: if they say the keyword tomorrow, they die. They learn the keyword." },
            organ_grinder: { id: 'organ_grinder', name: 'Organ Grinder', type: 'Minion', ability: "All players are 'mad' that they are the Organ Grinder, or you die. Evil players are not affected by this 'madness'." },
            pit_hag: { id: 'pit_hag', name: 'Pit-Hag', type: 'Minion', firstNight: 9, otherNight: 7, ability: "Each night, choose a player: they change character to one of your choice. If you change a Townsfolk into a Demon, they are the new Demon." },
            poisoner: { id: 'poisoner', name: 'Poisoner', type: 'Minion', firstNight: 4, otherNight: 3, ability: "Each night, choose a player: they are poisoned tonight and tomorrow day." },
            psychopath: { id: 'psychopath', name: 'Psychopath', type: 'Minion', ability: "Each day, you may publicly choose a player: they die." },
            scarlet_woman: { id: 'scarlet_woman', name: 'Scarlet Woman', type: 'Minion', ability: "If there are 5 or more players alive & the Demon dies, you become the Demon. (You do not die.)" },
            spy: { id: 'spy', name: 'Spy', type: 'Minion', firstNight: 9, otherNight: 8, ability: "Each night, you see the Grimoire. You might register as good, even to yourself at night." },
            summoner: { id: 'summoner', name: 'Summoner', type: 'Minion', ability: "Each night, choose a player: they die. If they are a Minion, they are resurrected as a different Minion. [+1 Minion]" },
            vizier: { id: 'vizier', name: 'Vizier', type: 'Minion', ability: "All players know you are the Vizier. You can not die. If the good team wins, you win too." },
            widow: { id: 'widow', name: 'Widow', type: 'Minion', firstNight: 10, ability: "On your 1st night, you see the Grimoire. Once per game, at night, choose a player: they are poisoned." },
            witch: { id: 'witch', name: 'Witch', type: 'Minion', otherNight: 5, ability: "Each night*, choose a player: they are cursed. When they are next nominated, they must be executed, or the good team loses." },
            wizard: { id: 'wizard', name: 'Wizard', type: 'Minion', firstNight: 1, ability: "You start knowing all Outsiders. All Outsiders know you are the Wizard. If you are executed, all Outsiders die." },
            xaan: { id: 'xaan', name: 'Xaan', type: 'Minion', ability: "Each night, choose a player: they register as your alignment. Once per game, if the Demon is executed, a new Demon is created." },
            // Traveller minions
            bone_collector: { id: 'bone_collector', name: 'Bone Collector', type: 'Minion', ability: "Once per game, at night, choose a dead player: they are revived, but you die." },
            gangster: { id: 'gangster', name: 'Gangster', type: 'Minion', ability: "Once per game, during the day, you may choose a player: they die. All other evil players know who you are." },
            voudon: { id: 'voudon', name: 'Voudon', type: 'Minion', otherNight: 6, ability: "Each night, choose a player. They are 'stitched' to one of their neighbors. If the 'stitched' player dies, their neighbor dies too." },
            // Demons
            al_hadikhia: { id: 'al_hadikhia', name: 'Al-Hadikhia', type: 'Demon', otherNight: 8, ability: "Each night*, choose 3 players: they die if all 3 are good and alive. Otherwise, nothing happens. If you die, all players not on your team die." },
            fang_gu: { id: 'fang_gu', name: 'Fang Gu', type: 'Demon', otherNight: 8, ability: "Each night*, choose a player: they die. The 1st time an Outsider dies, you become that Outsider. A Minion becomes the Fang Gu." },
            imp: { id: 'imp', name: 'Imp', type: 'Demon', otherNight: 8, ability: "Each night*, choose a player: they die. If you kill yourself, a Minion becomes the new Imp." },
            kazali: { id: 'kazali', name: 'Kazali', type: 'Demon', otherNight: 8, ability: "Each night*, choose a player: they die. If a Minion is executed, they are not drunk tonight and their alignment does not change." },
            legion: { id: 'legion', name: 'Legion', type: 'Demon', otherNight: 8, ability: "Each night*, a player of your choice dies. You are 'Legion'. Many players may be Legion. Legion is the Demon. If a Legion is executed, a new Legion may be created." },
            leviathan: { id: 'leviathan', name: 'Leviathan', type: 'Demon', ability: "On day 5, the game ends and evil wins. Each day, all players vote. The player with the most votes is executed. In a tie, no one is executed." },
            lil_monsta: { id: 'lil_monsta', name: 'Lil\' Monsta', type: 'Demon', ability: "Each night, a Minion receives a 'token'. The Minion with the token chooses a player: they die. You are a Minion that is told they are the Demon. If you are the last evil player, you become the Demon." },
            lleech: { id: 'lleech', name: 'Lleech', type: 'Demon', firstNight: 10, ability: "On your 1st night, choose a player: they are your 'host'. Each night*, they die. While your 'host' lives, you can't die. If you die, they become a Lleech." },
            lord_of_typhon: { id: 'lord_of_typhon', name: 'Lord of Typhon', type: 'Demon', ability: "The first time you die, a good player becomes a new Lord of Typhon. You become their old character. They do not know they are the Demon." },
            no_dashii: { id: 'no_dashii', name: 'No Dashii', type: 'Demon', otherNight: 8, ability: "Each night*, choose a player: they die. Your 2 Townsfolk neighbors are poisoned." },
            ojo: { id: 'ojo', name: 'Ojo', type: 'Demon', otherNight: 8, ability: "Each night*, choose a player: they die. The player that nominated you today might die tonight. If so, your kill fails." },
            po: { id: 'po', name: 'Po', type: 'Demon', otherNight: 8, ability: "Each night*, choose 3 players. Only one of them dies. If you choose yourself, you die and 2 players become a Po. [+1 Demon]" },
            pukka: { id: 'pukka', name: 'Pukka', type: 'Demon', otherNight: 8, ability: "Each night*, choose a player: they are poisoned. The 1st time you are poisoned, you die instead. Poisoned players do not die from poison." },
            riot: { id: 'riot', name: 'Riot', type: 'Demon', ability: "Each night, choose a character. If a player of this character is nominated tomorrow, they die. The game ends when only 2 players are left." },
            shabaloth: { id: 'shabaloth', name: 'Shabaloth', type: 'Demon', otherNight: 8, ability: "Each night*, choose 2 players: they die. You may choose the same player twice. If you kill a player, a dead player might be resurrected." },
            vigormortis: { id: 'vigormortis', name: 'Vigormortis', type: 'Demon', otherNight: 8, ability: "Each night*, choose a player: they die. Minions you kill are 'resurrected' as a different Minion, and they know it. Townsfolk you kill are poisoned." },
            vortox: { id: 'vortox', name: 'Vortox', type: 'Demon', otherNight: 8, ability: "Each night*, choose a player: they die. Townsfolk abilities yield false info. Each time a good player dies by execution, an evil player might be executed." },
            yaggababble: { id: 'yaggababble', name: 'Yaggababble', type: 'Demon', ability: "You must publicly choose a player each day. They are 'cursed'. At night, a 'cursed' player might die. There can only be 1 'cursed' player at a time." },
            zombuul: { id: 'zombuul', name: 'Zombuul', type: 'Demon', otherNight: 8, ability: "Each night*, choose a player: they die. The 1st time you die, you live. You can't kill the same night you were 'dead'." },
        };
        const SCRIPTS = {
            tb: { name: "Trouble Brewing", roles: ['chef', 'investigator', 'washerwoman', 'librarian', 'empath', 'fortune_teller', 'undertaker', 'monk', 'ravenkeeper', 'slayer', 'soldier', 'virgin', 'mayor', 'butler', 'drunk', 'recluse', 'saint', 'poisoner', 'spy', 'scarlet_woman', 'baron', 'imp'] },
            bmr: { name: "Bad Moon Rising", roles: ['chambermaid', 'exorcist', 'innkeeper', 'grandmother','gambler', 'gossip', 'courtier', 'professor', 'minstrel', 'sailor', 'tea_lady', 'pacifist', 'fool', 'tinker', 'moonchild', 'goon', 'lunatic', 'godfather', 'devil_s_advocate', 'assassin', 'mastermind', 'zombuul', 'pukka', 'shabaloth', 'po'] },
            sv: { name: "Sects & Violets", roles: ['clockmaker', 'dreamer', 'snake_charmer', 'mathematician', 'flowergirl', 'town_crier', 'oracle', 'savant', 'seamstress', 'philosopher', 'artist', 'juggler', 'sage', 'mutant', 'sweetheart', 'barber', 'klutz', 'evil_twin', 'witch', 'cerenovus', 'pit_hag', 'fang_gu', 'vortox', 'no_dashii', 'vigormortis'] },
            catfishing: { name: "Catfishing", roles: ['chef', 'empath', 'fortune_teller', 'flowergirl', 'town_crier', 'ravenkeeper', 'slayer', 'philosopher', 'artist', 'juggler', 'sage', 'recluse', 'lunatic', 'sweetheart', 'spy', 'poisoner', 'pit_hag', 'fang_gu', 'vortox'] },
            laissez_faire: { name: "Laissez-faire", roles: ['chambermaid', 'courtier', 'exorcist', 'fool', 'gossip', 'innkeeper', 'minstrel', 'pacifist', 'professor', 'tea_lady', 'goon', 'moonchild', 'tinker', 'assassin', 'godfather', 'mastermind', 'pukka', 'shabaloth', 'zombuul'] },
        };
        const ROLE_TYPES = ['Townsfolk', 'Outsider', 'Minion', 'Demon'];
        const RECOMMENDED_COUNTS = {
            5: { "Townsfolks": 3, "Outsiders": 0, "Minions": 1, "Demons": 1 },
            6: { "Townsfolks": 3, "Outsiders": 1, "Minions": 1, "Demons": 1 },
            7: { "Townsfolks": 5, "Outsiders": 0, "Minions": 1, "Demons": 1 },
            8: { "Townsfolks": 5, "Outsiders": 1, "Minions": 1, "Demons": 1 },
            9: { "Townsfolks": 5, "Outsiders": 2, "Minions": 1, "Demons": 1 },
            10: { "Townsfolks": 7, "Outsiders": 0, "Minions": 2, "Demons": 1 },
            11: { "Townsfolks": 7, "Outsiders": 1, "Minions": 2, "Demons": 1 },
            12: { "Townsfolks": 7, "Outsiders": 2, "Minions": 2, "Demons": 1 },
            13: { "Townsfolks": 9, "Outsiders": 0, "Minions": 3, "Demons": 1 },
            14: { "Townsfolks": 9, "Outsiders": 1, "Minions": 3, "Demons": 1 },
            15: { "Townsfolks": 9, "Outsiders": 2, "Minions": 3, "Demons": 1 }
        };

        // Configuration for roles that think they are another role
        const THINKER_ROLES = {
            drunk: { id: 'drunk', name: 'Drunk', thinksAs: ['Townsfolk'] },
            lunatic: { id: 'lunatic', name: 'Lunatic', thinksAs: ['Demon'] },
            philosopher: { id: 'philosopher', name: 'Philosopher', thinksAs: ['Townsfolk'] },
            cannibal: { id: 'cannibal', name: 'Cannibal', thinksAs: ['Townsfolk'] },
        };

        // Configuration for roles that create visual links to other players via tokens
        const LINKER_ROLES = {
            monk: { tokens: [{ id: 'monk-protect', icon: '🛡️', color: 'white', max: 1 }] },
            butler: { tokens: [{ id: 'butler-master', icon: '👑', color: 'var(--outsider)', max: 1 }] },
            poisoner: { tokens: [{ id: 'poisoner-poison', icon: '☠️', color: 'var(--poison)', max: 1 }] },
            grandmother: { tokens: [{ id: 'grandmother-child', icon: '👶', color: 'var(--townsfolk)', max: 1 }] },
            sailor: { tokens: [{ id: 'sailor-drunk', icon: '🍻', color: 'var(--townsfolk)', max: 1 }] },
            innkeeper: {
                tokens: [
                    { id: 'innkeeper-protect', icon: '🛡️', color: 'white', max: 2 },
                    { id: 'innkeeper-drunk', icon: '🍻', color: 'var(--yellow)', max: 1 }
                ]
            },
            courtier: { tokens: [{ id: 'courtier-drunk', icon: '🍻', color: 'var(--townsfolk)', max: 1 }] },
            tea_lady: { tokens: [{ id: 'tea_lady-protect', icon: '🛡️', color: 'white', max: 2 }] },
            moonchild: { tokens: [{ id: 'moonchild-curse', icon: '🌙', color: 'var(--outsider)', max: 1 }] },
            goon: { tokens: [{ id: 'goon-drunk', icon: '🍻', color: 'var(--outsider)', max: 1 }] },
            devil_s_advocate: { tokens: [{ id: 'devils_advocate-protect', icon: '🛡️', color: 'white', max: 1 }] },
            pukka: { tokens: [{ id: 'pukka-poison', icon: '☠️', color: 'var(--poison)', max: 1 }] },
            shabaloth: { tokens: [{ id: 'shabaloth-eaten', icon: '🍽️', color: 'var(--demon)', max: 2 }] },
            snake_charmer: { tokens: [{ id: 'snake_charmer-swap', icon: '🍻', color: 'var(--townsfolk)', max: 1 }] },
            mathematician: { tokens: [{ id: 'mathematician-malfunction', icon: '❓', color: 'var(--townsfolk)', max: 5 }] },
            philosopher: { tokens: [{ id: 'philosopher-drunk', icon: '🍻', color: 'var(--townsfolk)', max: 1 }] },
            sweetheart: { tokens: [{ id: 'sweetheart-drunk', icon: '🍻', color: 'var(--outsider)', max: 1 }] },
            barber: { tokens: [{ id: 'barber-haircut', icon: '✂️', color: 'var(--outsider)', max: 1 }] },
            evil_twin: { tokens: [{ id: 'evil_twin-twin', icon: '👯', color: 'var(--minion)', max: 1 }] },
            witch: { tokens: [{ id: 'witch-curse', icon: '🧙‍♀️', color: 'var(--minion)', max: 1 }] },
            cerenovus: { tokens: [{ id: 'cerenovus-mad', icon: '😵', color: 'var(--minion)', max: 1 }] },
            no_dashii: { tokens: [{ id: 'no_dashii-poison', icon: '☠️', color: 'var(--poison)', max: 2 }] },
            vigormortis: { tokens: [{ id: 'vigormortis-poison', icon: '☠️', color: 'var(--poison)', max: 1 }] },
            bounty_hunter: { tokens: [{ id: 'bounty_hunter-target', icon: '🎯', color: 'var(--minion)', max: 1 }] },
            fortune_teller: { tokens: [{ id: 'fortune_teller-red_herring', icon: '🐟', color: 'var(--townsfolk)', max: 1 }] },
            gossip: { tokens: [{ id: 'gossip-claim', icon: '🗣️', color: 'var(--townsfolk)', max: 1 }] },
            juggler: { tokens: [{ id: 'juggler-guess', icon: '❓', color: 'var(--townsfolk)', max: 5 }] },
            philosopher: { tokens: [{ id: 'philosopher-drunk', icon: '🍻', color: 'var(--townsfolk)', max: 1 }] },
            pixie: { tokens: [{ id: 'pixie-curse', icon: '🧚', color: 'var(--outsider)', max: 1 }] },
            preacher: { tokens: [{ id: 'preacher-convert', icon: '✝️', color: 'var(--townsfolk)', max: 1 }] },
            princess: { tokens: [{ id: 'princess-claim', icon: '👑', color: 'var(--townsfolk)', max: 1 }] },
        };

        // --- APPLICATION STATE ---
        let state = {
            playerCount: 8,
            players: [],
            bluffs: [
                { id: 'bluff-1', role: null, notes: '' },
                { id: 'bluff-2', role: null, notes: '' },
                { id: 'bluff-3', role: null, notes: '' },
            ],
            activeScriptId: 'tb',
            notesModal: {
                isOpen: false,
                entityId: null,
            },
        };

        // --- RENDER & LOGIC FUNCTIONS ---

        function renderApp() {
            renderControls();
            renderTable();
            renderRoleLibrary();
            renderNightOrder();
            renderDemonBluffs();
            // A brief delay to ensure DOM elements are painted before drawing SVG
            setTimeout(renderVisualLinks, 0); 
            renderRoleCounts();
            attachAllEventListeners();
        }
        
        function initializeApp(playerCount) {
            const newPlayers = [];
            for (let i = 0; i < playerCount; i++) {
                const existingPlayer = state.players.find(p => p.id === i);
                newPlayers.push({
                    id: i,
                    name: existingPlayer ? existingPlayer.name : `Player ${i + 1}`,
                    role: existingPlayer ? existingPlayer.role : null,
                    thinksRole: existingPlayer ? existingPlayer.thinksRole : null,
                    status: 'alive',
                    notes: existingPlayer ? existingPlayer.notes : '',
                    links: existingPlayer ? existingPlayer.links : {},
                });
            }
            state.playerCount = playerCount;
            state.players = newPlayers;
            renderApp();
        }

        function renderControls() {
            const container = document.getElementById('table-controls');
            container.innerHTML = `
                <div>
                    <label for="player-count">Players:</label>
                    <select id="player-count">
                        ${[...Array(11).keys()].map(i => `<option value="${i+5}" ${state.playerCount === i+5 ? 'selected' : ''}>${i+5}</option>`).join('')}
                    </select>
                </div>
                <div>
                    <label for="script-select">View Roles From:</label>
                    <select id="script-select">
                        <option value="all" ${state.activeScriptId === 'all' ? 'selected' : ''}>All Roles</option>
                        ${Object.keys(SCRIPTS).map(id => `<option value="${id}" ${state.activeScriptId === id ? 'selected' : ''}>${SCRIPTS[id].name}</option>`).join('')}
                    </select>
                </div>
                <button id="clear-board-btn">Clear Board</button>
            `;
        }
        
        function renderTable() {
            const container = document.getElementById('table-container');
            container.innerHTML = state.players.map(player => `
                <div class="player-spot" data-player-id="${player.id}">
                    <div class="player-header">
                        <input type="text" class="player-name-input" data-player-id="${player.id}" value="${player.name}" placeholder="Player ${player.id + 1}">
                        <button class="death-toggle-btn ${player.status === 'dead' ? 'is-dead' : ''}" data-player-id="${player.id}" title="Toggle Dead/Alive">
                             💀
                        </button>
                    </div>
                    ${getCardHTML(player)}
                </div>
            `).join('');
        }
        
        function renderDemonBluffs() {
            const container = document.getElementById('demon-bluffs-content');
            container.innerHTML = state.bluffs.map((bluff, index) => `
                <div class="bluff-spot" data-bluff-id="${bluff.id}">
                    <input type="text" class="player-name-input" value="Bluff ${index + 1}" readonly>
                    ${getCardHTML(bluff)}
                </div>
            `).join('');
        }

        function getCardHTML(entity) {
            const trueRole = entity.role;
            const thinksRole = entity.thinksRole;
            const displayRole = thinksRole || trueRole;

            if (!displayRole) {
                return `<div class="player-card"><div class="player-card-placeholder">Drop Role Here</div></div>`;
            }
            
            const typeClass = (trueRole ? trueRole.type : displayRole.type).toLowerCase() + '-card';
            const deadClass = entity.status === 'dead' ? 'dead' : '';
            const hasNotes = entity.notes && entity.notes.length > 0;
            const thinkerRole = trueRole && THINKER_ROLES[trueRole.id] ? trueRole : null;
            const thinkerIndicator = thinkerRole ? ` <span class="thinker-indicator">(${thinkerRole.name})</span>` : '';

            // --- RENDER TOKENS ---
            
            // 1. Render Source Tokens (at the bottom of the card)
            let sourceTokensHTML = '';
            const linkerConfig = LINKER_ROLES[displayRole.id];
            if (linkerConfig) {
                const sourceTokenElements = linkerConfig.tokens.flatMap(token => {
                    const existingLinks = entity.links[token.id] || [];
                    const availableTokens = token.max - existingLinks.length;
                    let elements = [];
                    
                    // Gray "used" tokens
                    existingLinks.forEach(link => {
                        elements.push(`<div class="card-token used" data-token-instance="${token.id}-${entity.id}-${link.targetId}-source" title="Linked to ${state.players.find(p => p.id === link.targetId)?.name}">${token.icon}</div>`);
                    });

                    // Draggable "available" tokens
                    for (let i = 0; i < availableTokens; i++) {
                        elements.push(`<div class="card-token" draggable="true" data-token-source-id="${entity.id}" data-token-id="${token.id}">${token.icon}</div>`);
                    }
                    return elements;
                }).join('');
                sourceTokensHTML = `<div class="source-tokens-container">${sourceTokenElements}</div>`;
            }

            // 2. Render Received Tokens (at their drop coordinates)
            let receivedTokensHTML = '';
            const receivedTokens = [];
            state.players.forEach(sourcePlayer => {
                 if (!sourcePlayer.role && !sourcePlayer.thinksRole) return;
                 for (const tokenId in sourcePlayer.links) {
                    const links = sourcePlayer.links[tokenId] || [];
                    links.forEach(link => {
                        if (link.targetId === entity.id) {
                            const sourceRoleId = sourcePlayer.role?.id || sourcePlayer.thinksRole?.id;
                            const tokenConfig = LINKER_ROLES[sourceRoleId]?.tokens.find(t => t.id === tokenId);
                            if (tokenConfig) {
                                receivedTokens.push({
                                    ...tokenConfig,
                                    sourceId: sourcePlayer.id,
                                    targetId: entity.id,
                                    x: link.x,
                                    y: link.y
                                });
                            }
                        }
                    });
                 }
            });

            if (receivedTokens.length > 0) {
                 receivedTokensHTML = receivedTokens.map(token => `
                    <div class="card-token received-token" 
                         data-token-instance="${token.id}-${token.sourceId}-${token.targetId}-target"
                         data-source-id="${token.sourceId}"
                         data-target-id="${token.targetId}"
                         data-token-id="${token.id}"
                         style="top: ${token.y}px; left: ${token.x}px;"
                         title="From ${state.players.find(p => p.id === token.sourceId).name}. Click to remove.">
                         ${token.icon}
                    </div>
                `).join('');
            }

            return `
                <div class="player-card ${typeClass} ${deadClass}">
                     ${receivedTokensHTML}
                     <button class="notes-btn ${hasNotes ? 'has-notes' : ''}" data-entity-id="${entity.id}" title="${entity.notes ? entity.notes.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/\n/g, ' ') : ''}">
                        📝
                    </button>
                    <div>
                        <div class="player-card-header" style="border-color: var(--${(trueRole || displayRole).type.toLowerCase()});">${displayRole.name}${thinkerIndicator}</div>
                        <p class="player-card-ability">${displayRole.ability}</p>
                    </div>
                    ${sourceTokensHTML}
                    <p class="player-card-type">${(trueRole || displayRole).type}</p>
                </div>
            `;
        }

        function renderSvgDefs() {
            const defs = document.querySelector('#visual-links-svg defs');
            let markersHTML = '';
            for (const roleId in LINKER_ROLES) {
                LINKER_ROLES[roleId].tokens.forEach(token => {
                    markersHTML += `
                        <marker id="arrowhead-${token.id}" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="${token.color}" />
                        </marker>
                    `;
                });
            }
            defs.innerHTML = markersHTML;
        }
        
        function renderVisualLinks() {
            const svg = document.getElementById('visual-links-svg');
            const centerPanel = document.getElementById('center-panel');
            const panelRect = centerPanel.getBoundingClientRect();
            
            let linesHTML = svg.querySelector('defs').outerHTML;

            state.players.forEach(sourcePlayer => {
                for (const tokenId in sourcePlayer.links) {
                    const links = sourcePlayer.links[tokenId] || [];
                    const roleId = sourcePlayer.role?.id || sourcePlayer.thinksRole?.id;
                    const tokenConfig = LINKER_ROLES[roleId]?.tokens.find(t => t.id === tokenId);

                    if (tokenConfig) {
                        links.forEach(link => {
                            const sourceTokenSelector = `[data-token-instance='${tokenId}-${sourcePlayer.id}-${link.targetId}-source']`;
                            const targetTokenSelector = `[data-token-instance='${tokenId}-${sourcePlayer.id}-${link.targetId}-target']`;
                            const lineCoords = getLineCoords(sourceTokenSelector, targetTokenSelector, panelRect);
                             if (lineCoords) {
                                const style = `stroke: ${tokenConfig.color}; filter: drop-shadow(0  0 3px ${tokenConfig.color});`;
                                const marker = `marker-end="url(#arrowhead-${tokenConfig.id})"`;
                                linesHTML += `<line class="linker-line" style="${style}" ${marker} x1="${lineCoords.x1}" y1="${lineCoords.y1}" x2="${lineCoords.x2}" y2="${lineCoords.y2}" />`;
                            }
                        });
                    }
                }
            });

            svg.innerHTML = linesHTML;
        }

        function getLineCoords(sourceSelector, targetSelector, panelRect) {
            const sourceEl = document.querySelector(sourceSelector);
            const targetEl = document.querySelector(targetSelector);
            if (!sourceEl || !targetEl) return null;
            
            const sourceRect = sourceEl.getBoundingClientRect();
            const targetRect = targetEl.getBoundingClientRect();

            return {
                x1: sourceRect.left + sourceRect.width / 2 - panelRect.left,
                y1: sourceRect.top + sourceRect.height / 2 - panelRect.top,
                x2: targetRect.left + targetRect.width / 2 - panelRect.left,
                y2: targetRect.top + targetRect.height / 2 - panelRect.top
            };
        }


        function renderRoleLibrary() {
            const container = document.getElementById('role-library-content');
            
            const rolesToList = state.activeScriptId === 'all' 
                ? Object.values(ROLES)
                : SCRIPTS[state.activeScriptId].roles.map(id => ROLES[id]);

            container.innerHTML = ROLE_TYPES.map(type => {
                const filteredRoles = rolesToList.filter(r => r.type === type);
                if (filteredRoles.length === 0) return '';
                
                return `
                    <div class="role-group">
                        <h3 class="${type.toLowerCase()}-header">${type}s</h3>
                        <div class="role-group-body ${type.toLowerCase()}-body">
                            ${filteredRoles.map(role => `
                                <div class="role-card-small" draggable="true" data-role-id="${role.id}">
                                    ${role.name}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `
            }).join('');
        }

        function renderNightOrder() {
            const getDisplayRole = (player) => {
                const isThinker = player.role && THINKER_ROLES[player.role.id];
                return isThinker && player.thinksRole ? player.thinksRole : player.role;
            };
            const getOrder = (role, phase) => phase === 'first' ? role.firstNight : role.otherNight;

            const createSortedList = (phase) => state.players
                .filter(p => {
                    const displayRole = getDisplayRole(p);
                    return displayRole && p.status === 'alive' && getOrder(displayRole, phase);
                })
                .sort((a, b) => {
                    const aRole = getDisplayRole(a);
                    const bRole = getDisplayRole(b);
                    return getOrder(aRole, phase) - getOrder(bRole, phase);
                })
                .map(p => {
                    const displayRole = getDisplayRole(p);
                    return `<li>${displayRole.name} <span>(${p.name || `Player ${p.id + 1}`})</span></li>`;
                })
                .join('');

            const firstNightHTML = createSortedList('first');
            const otherNightsHTML = createSortedList('other');
            
            document.getElementById('night-order-content').innerHTML = `
                <div class="night-order-section">
                    <h3>First Night</h3>
                    ${firstNightHTML ? `<ol class="night-order-list">${firstNightHTML}</ol>` : `<p style="color: var(--text-med);">No first night actions.</p>`}
                </div>
                <div class="night-order-section">
                    <h3>Other Nights</h3>
                    ${otherNightsHTML ? `<ol class="night-order-list">${otherNightsHTML}</ol>` : `<p style="color: var(--text-med);">No other night actions.</p>`}
                </div>
            `;
        }

        function renderRoleCounts() {
            const container = document.getElementById('role-counts-content');
            const current = { "Townsfolks": 0, "Outsiders": 0, "Minions": 0, "Demons": 0 };
            
            state.players.forEach(p => {
                if (p.role) {
                    current[p.role.type + 's']++;
                }
            });
            
            const recommended = { ...RECOMMENDED_COUNTS[state.playerCount] };
            
            // Apply Baron modifier
            if (state.players.some(p => p.role && p.role.id === 'baron')) {
                recommended.Outsiders += 2;
                recommended.Townsfolks -= 2;
            }
            // Apply Fang Gu modifier
            if (state.players.some(p => p.role && p.role.id === 'fang_gu')) {
                recommended.Outsiders += 1;
                recommended.Townsfolks -= 1;
            }
            // Apply Vigormortis modifier
            if (state.players.some(p => p.role && p.role.id === 'vigormortis')) {
                recommended.Outsiders -= 1;
                recommended.Townsfolks += 1;
            }
            // Apply Atheist modifier
            if (state.players.some(p => p.role && p.role.id === 'atheist')) {
                recommended.Townsfolks += (recommended.Minions + recommended.Demons);
                recommended.Demons -= recommended.Demons;
                recommended.Minions -= recommended.Minions;
                
            }

            const getCountClass = (current, recommended) => {
                if (current === recommended) return 'count-ok';
                if (current < recommended) return 'count-under';
                return 'count-over';
            };

            container.innerHTML = `
                <div class="role-count-grid">
                    ${Object.keys(recommended).map(type => {
                        const currentCount = current[type];
                        const recommendedCount = recommended[type];
                        return `<div style="--color: var(--${type.toLowerCase().slice(0, -1)}); display: flex; flex-direction: column; align-items: center; padding: 0.5em 0;">
                            <span class="role-label">${type}</span>
                            <span class="role-count-value ${getCountClass(currentCount, recommendedCount)}">
                                ${currentCount} / ${recommendedCount}
                            </span>
                        </div>`
                    }).join('')}
                </div>
            `;
        }
        
        function handleClearBoard() {
            state.players.forEach(p => {
                p.role = null;
                p.thinksRole = null;
                p.status = 'alive';
                p.notes = '';
                p.links = {};
            });
            state.bluffs.forEach(b => {
                b.role = null;
                b.notes = '';
            });
            renderApp();
        }
        
        function handleScriptLoad(scriptId) {
            state.activeScriptId = scriptId;
            renderRoleLibrary();
        }

        function attachAllEventListeners() {
            document.getElementById('player-count').addEventListener('change', e => initializeApp(parseInt(e.target.value, 10)));
            document.getElementById('script-select').addEventListener('change', e => handleScriptLoad(e.target.value));
            document.getElementById('clear-board-btn').addEventListener('click', handleClearBoard);
        }
        
        function openNotesModal(entityId) {
            const player = state.players.find(p => p.id === entityId);
            const bluff = state.bluffs.find(b => b.id === entityId);
            const entity = player || bluff;
            if (!entity) return;

            state.notesModal.entityId = entityId;
            let title = 'Notes';
            const displayRole = entity.thinksRole || entity.role;
            if (displayRole) {
                 if (player) {
                    title = `Notes for ${player.name || `Player ${player.id + 1}`} (${displayRole.name})`;
                 } else if (bluff) {
                    title = `Notes for Bluff (${displayRole.name})`
                 }
            }
            
            document.getElementById('notes-modal-title').textContent = title;
            document.getElementById('notes-modal-textarea').value = entity.notes || '';
            document.getElementById('notes-modal-backdrop').classList.remove('hidden');
        }

        function closeNotesModal() {
            document.getElementById('notes-modal-backdrop').classList.add('hidden');
        }

        function saveNotes() {
            const entityId = state.notesModal.entityId;
            const player = state.players.find(p => p.id === entityId);
            const bluff = state.bluffs.find(b => b.id === entityId);
            const entity = player || bluff;

            if (entity) {
                entity.notes = document.getElementById('notes-modal-textarea').value;
            }
            closeNotesModal();
            if (player) renderTable();
            if (bluff) renderDemonBluffs();
        }


        function setupEventListeners(){
            // Role library drag
            document.getElementById('role-library-content').addEventListener('dragstart', e => {
                if (e.target.matches('.role-card-small')) {
                    e.dataTransfer.setData('application/json', JSON.stringify({type: 'role', id: e.target.dataset.roleId}));
                }
            });

            const mainContainer = document.getElementById('app-container');
            
            // Token drag
            mainContainer.addEventListener('dragstart', e => {
                if (e.target.matches('.card-token')) {
                    e.stopPropagation();
                    document.body.classList.add('dragging-token');
                    e.dataTransfer.setData('application/json', JSON.stringify({
                        type: 'token',
                        sourceId: parseInt(e.target.dataset.tokenSourceId, 10),
                        tokenId: e.target.dataset.tokenId,
                    }));
                }
            });
            mainContainer.addEventListener('dragend', e => {
                 if (document.body.classList.contains('dragging-token')) {
                     document.body.classList.remove('dragging-token');
                 }
            });


            mainContainer.addEventListener('dragover', e => {
                e.preventDefault();
                const spot = e.target.closest('.player-spot');
                if (spot) {
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    spot.classList.add('drag-over');
                }
            });

            mainContainer.addEventListener('dragleave', e => {
                const spot = e.target.closest('.player-spot');
                if (spot) spot.classList.remove('drag-over');
            });

            mainContainer.addEventListener('drop', e => {
                e.preventDefault();
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                document.body.classList.remove('dragging-token'); // Ensure cursor resets after drop
                try {
                    const data = JSON.parse(e.dataTransfer.getData('application/json'));
                    if (!data) return;

                    // Allow drop on player-spot or bluff-spot
                    const targetPlayerSpot = e.target.closest('.player-spot');
                    const targetBluffSpot = e.target.closest('.bluff-spot');

                    if (data.type === 'role') {
                        if (targetPlayerSpot) {
                            const targetId = parseInt(targetPlayerSpot.dataset.playerId, 10);
                            handleRoleDrop(data.id, targetId);
                        } else if (targetBluffSpot) {
                            const bluffId = targetBluffSpot.dataset.bluffId;
                            handleBluffRoleDrop(data.id, bluffId);
                        }
                    } else if (data.type === 'token' && targetPlayerSpot) {
                        const targetCard = e.target.closest('.player-card');
                        if (!targetCard) return;
                        const targetId = parseInt(targetPlayerSpot.dataset.playerId, 10);
                        const rect = targetCard.getBoundingClientRect();
                        const x = e.clientX - rect.left - 12;
                        const y = e.clientY - rect.top - 12;
                        handleTokenDrop(data.sourceId, data.tokenId, targetId, x, y);
                    }
                } catch(err) {
                    // Could be a drag from outside the window
                    console.log("Drag drop error", err);
                }
            });
            
            document.getElementById('table-container').addEventListener('click', e => {
                 if (e.target.closest('.death-toggle-btn')) {
                    const playerId = parseInt(e.target.closest('.death-toggle-btn').dataset.playerId, 10);
                    handleDeathToggle(playerId);
                    return;
                }
                 if (e.target.closest('.notes-btn')) {
                    const entityId = e.target.closest('.notes-btn').dataset.entityId.startsWith('bluff') ? e.target.closest('.notes-btn').dataset.entityId : parseInt(e.target.closest('.notes-btn').dataset.entityId, 10);
                    openNotesModal(entityId);
                    return;
                }
                if (e.target.matches('.received-token')) {
                const sourceId = parseInt(e.target.dataset.sourceId, 10);
                const targetId = parseInt(e.target.dataset.targetId, 10);
                const tokenId = e.target.dataset.tokenId;
                removeLink(sourceId, tokenId, targetId);
                return;
                }
            });
            
             document.getElementById('table-container').addEventListener('change', e => {
                if (e.target.matches('.player-name-input')) {
                    const playerId = parseInt(e.target.dataset.playerId, 10);
                    const player = state.players.find(p => p.id === playerId);
                    if (player) {
                        player.name = e.target.value;
                        renderNightOrder(); // Only need to re-render this, not the whole app
                    }
                } 
            });

            // Modal listeners
            document.getElementById('notes-modal-cancel').addEventListener('click', closeNotesModal);
            document.getElementById('notes-modal-save').addEventListener('click', saveNotes);
        }

        function handleRoleDrop(roleId, targetPlayerId) {
            const player = state.players.find(p => p.id === targetPlayerId);
            const droppedRole = ROLES[roleId];
            const currentRole = player.role;
            const droppedRoleThinkerConfig = THINKER_ROLES[droppedRole.id];
            const currentRoleThinkerConfig = currentRole ? THINKER_ROLES[currentRole.id] : null;

            if (droppedRoleThinkerConfig && currentRole && droppedRoleThinkerConfig.thinksAs.includes(currentRole.type)) {
                player.thinksRole = currentRole;
                player.role = droppedRole;
            } else if (currentRoleThinkerConfig && currentRoleThinkerConfig.thinksAs.includes(droppedRole.type)) {
                player.thinksRole = droppedRole;
            } else {
                player.role = droppedRole;
                player.thinksRole = null;
                player.links = {}; // Clear links on role change
            }
            renderApp();
        }
        
        function handleBluffRoleDrop(roleId, bluffId) {
            const bluff = state.bluffs.find(b => b.id === bluffId);
            if (bluff) {
                bluff.role = ROLES[roleId];
                bluff.thinksRole = null;
                bluff.links = {};
                renderDemonBluffs();
            }
        }
        
        function removeLink(sourceId, tokenId, targetId) {
            const sourcePlayer = state.players.find(p => p.id === sourceId);
            if (!sourcePlayer || !sourcePlayer.links[tokenId]) return;
            
            sourcePlayer.links[tokenId] = sourcePlayer.links[tokenId].filter(link => link.targetId !== targetId);

            renderApp();
        }

        function handleTokenDrop(sourceId, tokenId, targetId, x, y) {
            const sourcePlayer = state.players.find(p => p.id === sourceId);
            if (!sourcePlayer || sourcePlayer.id === targetId) return;

            const roleId = sourcePlayer.role?.id || sourcePlayer.thinksRole?.id;
            const tokenConfig = LINKER_ROLES[roleId]?.tokens.find(t => t.id === tokenId);
            if (!tokenConfig) return;

            if (!sourcePlayer.links[tokenId]) {
                sourcePlayer.links[tokenId] = [];
            }
            const existingLinks = sourcePlayer.links[tokenId];
            
            // Check if link already exists. If so, do nothing. Click handler removes links.
            if (existingLinks.some(link => link.targetId === targetId)) {
                return;
            }
           
            if (existingLinks.length < tokenConfig.max) {
                existingLinks.push({ targetId, x, y });
            }
            
            renderApp();
        }

        function handleDeathToggle(playerId) {
            const player = state.players.find(p => p.id === playerId);
            if (player) {
                player.status = (player.status === 'alive') ? 'dead' : 'alive';
            }
            renderApp();
        }


        // --- INITIALIZE ---
        document.addEventListener('DOMContentLoaded', () => {
            renderSvgDefs();
            initializeApp(state.playerCount);
            setupEventListeners();
        });

    </script>
</body>
</html>
