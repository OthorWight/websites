<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klondike Solitaire</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Merriweather:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --card-width: 100px;
            --card-height: 140px;
            --card-border-radius: 8px;
            --board-padding: 20px;
            --pile-gap: 15px;
            --tableau-offset-faceup: 35px;
            --tableau-offset-facedown: 12px;
        }

        /* --- Basic Styling & Theme --- */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a3a1a; /* Darker, richer green */
            background-image: radial-gradient(circle at center, #3a5a3a, #1a3a1a);
            color: #fff;
            margin: 0;
            padding: 10px;
            user-select: none;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        #game-board {
            position: relative;
            width: 100%;
            min-height: 880px;
            max-width: 900px;
            margin: 15px auto;
            border: 2px solid #112211;
            background-color: #2a4a2a;
            padding: var(--board-padding);
            box-sizing: border-box;
            border-radius: 15px;
            box-shadow: 
                inset 0 0 15px rgba(0,0,0,0.5), /* Inner shadow for depth */
                0 10px 30px rgba(0,0,0,0.4);   /* Outer shadow for lift */
            overflow: hidden; /* Contain bouncing cards */
        }

        /* --- Layout Rules --- */
        .top-row, .tableau-row {
            display: flex;
            gap: var(--pile-gap);
        }
        
        .top-row {
            justify-content: space-between;
            margin-bottom: 25px;
            min-height: var(--card-height);
        }

        .top-row .left {
            display: flex;
            gap: var(--pile-gap);
        }
        
        .top-row .right.foundations {
            display: flex;
            gap: var(--pile-gap);
        }
        
        .tableau-row {
            justify-content: space-around;
        }

        /* --- Pile Styling --- */
        .pile {
            position: relative;
            width: var(--card-width);
            height: var(--card-height);
            border-radius: var(--card-border-radius);
            background-color: rgba(0, 0, 0, 0.15);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .tableau.pile {
            min-height: calc(var(--card-height) * 3);
            background-color: transparent;
            box-shadow: none;
        }
        
        /* Placeholder for empty piles */
        .pile.empty::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--card-height);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: var(--card-border-radius);
            box-sizing: border-box;
        }
        
        /* Foundation placeholders with suit symbols */
        .foundation.empty::after {
            position: absolute;
            top: 48%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Merriweather', serif;
            font-size: 70px;
            color: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            text-align: center;
            letter-spacing: 0px;
            line-height: 0.8;
        }
        #foundation-0.empty::after,
        #foundation-1.empty::after,
        #foundation-2.empty::after,
        #foundation-3.empty::after { content: '♥♠\A♣♦'; }

        #stock.pile.empty::before {
            content: '♻️';
            font-size: 50px;
            text-align: center;
            line-height: var(--card-height);
            color: rgba(255, 255, 255, 0.3);
            border-style: solid;
        }

        /* --- Card Styling --- */
        .card {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            cursor: pointer;
            perspective: 1000px;
            background-color: transparent;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.5s;
            transform-style: preserve-3d;
        }

        .card.face-down .card-inner {
            transform: rotateY(-180deg);
        }

        .card-front,
        .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: var(--card-border-radius);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            box-sizing: border-box;
        }

        .card-front {
            background-color: #f8f8f8;
            color: #1c1c1c;
            font-family: 'Merriweather', serif;
            font-size: 24px;
            font-weight: 700;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px;
        }

        .card-back {
            background-color: #1d4a7e;
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px),
                radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1), rgba(255,255,255,0) 50%),
                radial-gradient(circle at 75% 75%, rgba(255,255,255,0.1), rgba(255,255,255,0) 50%);
            background-size: 20px 20px;
            border: 1px solid #112233;
            transform: rotateY(-180deg);
        }

        .card:not(.face-down):hover .card-front {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }

        .card .rank { line-height: 1; }
        .card .suit { font-size: 36px; text-align: center; line-height: 1; }
        .card .rank-bottom { transform: rotate(180deg); line-height: 1; }
        .card.red .card-front { color: #d90429; }
        .card.black .card-front { color: #1c1c1c; }

        .card.dragging {
            opacity: 0.8;
            z-index: 1000 !important;
            cursor: grabbing;
            transition: none !important;
            will-change: top, left;
            position: absolute !important;
        }
        .card.dragging .card-front, .card.dragging .card-back {
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
        }

        /* --- Controls & Messages --- */
        #controls {
            margin-bottom: 15px;
            text-align: center;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 700;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            background: linear-gradient(145deg, #f0f0f0, #cccccc);
            border: 1px solid #999;
            border-radius: 8px;
            color: #333;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.15s ease-in-out;
        }

        button:hover:not(:disabled) {
            background: linear-gradient(145deg, #ffffff, #d9d9d9);
            box-shadow: 0 4px 8px rgba(0,0,0,0.25);
            transform: translateY(-2px);
        }
        
        button:active:not(:disabled) {
            background: linear-gradient(145deg, #cccccc, #f0f0f0);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }

        button:disabled {
            background: #b0b0b0;
            color: #666;
            cursor: not-allowed;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }

        #win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background-color: rgba(26, 58, 26, 0.95);
            backdrop-filter: blur(5px);
            color: #ffd700;
            padding: 40px 60px;
            border-radius: 15px;
            border: 2px solid #ffd700;
            font-size: 2.5em;
            font-weight: bold;
            text-align: center;
            z-index: 3000;
            display: none;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }
        
        #win-message.visible {
            display: block;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        #win-message small {
            font-size: 0.5em;
            color: #fff;
            font-weight: 400;
        }

        /* --- Media Queries for Responsiveness --- */
        @media (max-width: 850px) {
            :root {
                --card-width: 80px;
                --card-height: 112px;
                --pile-gap: 10px;
                --board-padding: 15px;
                --tableau-offset-faceup: 28px;
            }
            .card-front { font-size: 20px; padding: 6px; }
            .card .suit { font-size: 28px; }
            .foundation.empty::after { font-size: 40px; }
        }

        @media (max-width: 640px) {
            :root {
                --card-width: 60px;
                --card-height: 84px;
                --pile-gap: 8px;
                --board-padding: 10px;
                --tableau-offset-faceup: 22px;
                --tableau-offset-facedown: 8px;
            }
            body { padding: 5px; }
            #game-board { margin-top: 10px; }
            .card-front { font-size: 16px; padding: 4px; }
            .card { border-radius: 6px; }
            .card .suit { font-size: 20px; }
            .pile { border-radius: 6px; }
            .top-row { margin-bottom: 15px; }
            .foundation.empty::after { font-size: 30px; }
            #stock.pile.empty::before { font-size: 30px; line-height: 84px;}
            button { padding: 8px 15px; font-size: 14px; }
        }

        @media (max-width: 480px) {
            :root {
                --card-width: 45px;
                --card-height: 63px;
                --pile-gap: 5px;
                --board-padding: 8px;
                --tableau-offset-faceup: 18px;
                --tableau-offset-facedown: 6px;
            }
            .card-front { font-size: 12px; padding: 3px; }
            .card { border-radius: 4px; }
            .card .suit { font-size: 14px; }
            .pile { border-radius: 4px; }
            .top-row { margin-bottom: 10px; }
            .foundation.empty::after { font-size: 24px; }
            #stock.pile.empty::before { font-size: 24px; line-height: 63px;}
            #win-message { padding: 20px 30px; font-size: 1.5em; }
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="new-game">New Game</button>
        <button id="undo-button" disabled>Undo</button>
        <button id="auto-move-button">Auto Move</button>
    </div>

    <div id="game-board">
        <div class="top-row">
            <div class="left">
                <div id="stock" class="pile"></div>
                <div id="waste" class="pile"></div>
            </div>
            <div class="right foundations">
                <div id="foundation-0" class="pile foundation"></div>
                <div id="foundation-1" class="pile foundation"></div>
                <div id="foundation-2" class="pile foundation"></div>
                <div id="foundation-3" class="pile foundation"></div>
            </div>
        </div>
        <div class="tableau-row">
            <div id="tableau-0" class="pile tableau"></div>
            <div id="tableau-1" class="pile tableau"></div>
            <div id="tableau-2" class="pile tableau"></div>
            <div id="tableau-3" class="pile tableau"></div>
            <div id="tableau-4" class="pile tableau"></div>
            <div id="tableau-5" class="pile tableau"></div>
            <div id="tableau-6" class="pile tableau"></div>
        </div>
    </div>
    
    <div id="win-message">
        🎉 You Win! 🎉
        <br>
        <small>Click "New Game" to play again</small>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Constants & State ---
            const suits = ['H', 'D', 'C', 'S'];
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'];
            const rankValues = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13 };
            const suitColors = { 'H': 'red', 'D': 'red', 'C': 'black', 'S': 'black' };
            const suitSymbols = { 'H': '♥', 'D': '♦', 'C': '♣', 'S': '♠' };
            
            let deck = [];
            let stock = [];
            let waste = [];
            let foundations = Array.from({ length: 4 }, () => []);
            let tableau = Array.from({ length: 7 }, () => []);
            
            // DOM Elements
            const stockPileEl = document.getElementById('stock');
            const wastePileEl = document.getElementById('waste');
            const foundationPileEls = document.querySelectorAll('.foundation');
            const tableauPileEls = document.querySelectorAll('.tableau');
            const gameBoardEl = document.getElementById('game-board');
            const newGameButton = document.getElementById('new-game');
            const winMessageEl = document.getElementById('win-message');
            const autoMoveButton = document.getElementById('auto-move-button');
            const undoButton = document.getElementById('undo-button');
            
            // Drag State
            let draggedCards = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            
            // Visual Offsets from CSS variables for JS calculations
            let cardVerticalOffset = 35;
            let cardFaceDownOffset = 12;

            // Undo/Replay State
            let moveHistory = [];
            let initialGameState = null;
            let isReplaying = false;
            let replayTimeout = null;
            
            // --- Win Animation State ---
            let winAnimationId = null;
            let bouncingCards = [];
            
            // Animation Cancel State
            let currentAnimationFrame = null;

            // --- Core Functions ---
            function createCard(suit, rank) {
                const card = { 
                    suit, 
                    rank, 
                    faceUp: false, 
                    id: rank + suit, 
                    color: suitColors[suit], 
                    value: rankValues[rank], 
                    symbol: suitSymbols[suit], 
                    element: null 
                };
                card.element = createCardElement(card);
                return card;
            }

            function createCardElement(card) {
                const el = document.createElement('div');
                el.classList.add('card', card.color);
                el.dataset.cardId = card.id;
                el.draggable = false;

                const cardInner = document.createElement('div');
                cardInner.classList.add('card-inner');

                const cardFront = document.createElement('div');
                cardFront.classList.add('card-front');

                const cardBack = document.createElement('div');
                cardBack.classList.add('card-back');

                const rankTop = document.createElement('span');
                rankTop.classList.add('rank');
                rankTop.textContent = card.rank === 'T' ? '10' : card.rank;

                const suitMiddle = document.createElement('span');
                suitMiddle.classList.add('suit');
                suitMiddle.textContent = card.symbol;

                const rankBottom = document.createElement('span');
                rankBottom.classList.add('rank', 'rank-bottom');
                rankBottom.textContent = card.rank === 'T' ? '10' : card.rank;
                
                cardFront.appendChild(rankTop);
                cardFront.appendChild(suitMiddle);
                cardFront.appendChild(rankBottom);
                
                cardInner.appendChild(cardFront);
                cardInner.appendChild(cardBack);
                el.appendChild(cardInner);
                
                el.addEventListener('mousedown', onCardMouseDown);
                el.addEventListener('touchstart', onCardMouseDown, { passive: false });
                
                return el;
            }
            
            function updateCSSVariableOffsets() {
                const rootStyle = getComputedStyle(document.documentElement);
                cardVerticalOffset = parseInt(rootStyle.getPropertyValue('--tableau-offset-faceup'), 10) || 35;
                cardFaceDownOffset = parseInt(rootStyle.getPropertyValue('--tableau-offset-facedown'), 10) || 12;
            }
            
            function easeInOutQuad(t, b, c, d) {
                t /= d / 2;
                if (t < 1) return c / 2 * t * t + b;
                t--;
                return -c / 2 * (t * (t - 2) - 1) + b;
            }

            function animateCardMoves(moves, onComplete) {
                if (moves.length === 0) {
                    if (onComplete) onComplete();
                    return;
                }
                let startTime = performance.now();
                const duration = moves[0].duration || 300;

                moves.forEach((move, i) => {
                    if (move.element.parentElement !== gameBoardEl) gameBoardEl.appendChild(move.element);
                    move.element.style.position = 'absolute';
                    move.element.style.zIndex = 2000 + i;
                    move.element.style.left = `${move.startX}px`;
                    move.element.style.top = `${move.startY}px`;
                });

                function animationStep(currentTime) {
                    const elapsedTime = currentTime - startTime;
                    const progress = Math.min(1, elapsedTime / duration);

                    moves.forEach(move => {
                        const currentX = easeInOutQuad(elapsedTime, move.startX, move.targetX - move.startX, duration);
                        const currentY = easeInOutQuad(elapsedTime, move.startY, move.targetY - move.startY, duration);
                        move.element.style.left = `${currentX}px`;
                        move.element.style.top = `${currentY}px`;
                    });

                    if (progress < 1) {
                        currentAnimationFrame = requestAnimationFrame(animationStep);
                    } else {
                        moves.forEach(move => { move.element.style.zIndex = 'auto'; });
                        if (onComplete) onComplete();
                    }
                }
                currentAnimationFrame = requestAnimationFrame(animationStep);
            }

            function performAutoMovePass(onPassComplete) {
                if (draggedCards || isReplaying) {
                    onPassComplete(false);
                    return;
                }

                // Auto-draw from stock if waste is empty
                if (waste.length === 0 && stock.length > 0) {
                    const card = stock.pop();
                    if (card) {
                        card.faceUp = true;
                        waste.push(card);
                        recordMove({ type: 'stock_to_waste', cardData: { ...card, element: null } });
                        renderGame();
                        setTimeout(() => performAutoMovePass(onPassComplete), 100);
                    } else {
                        onPassComplete(false);
                    }
                    return;
                }

                const gameBoardRect = gameBoardEl.getBoundingClientRect();
                const animateAndContinue = (card, sourceInfo, targetInfo) => {
                    const cardElement = card.element;
                    const targetElement = targetInfo.element;
                    if (!cardElement || !targetElement) { onPassComplete(false); return; }

                    const startRect = cardElement.getBoundingClientRect();
                    const startX = startRect.left - gameBoardRect.left;
                    const startY = startRect.top - gameBoardRect.top;
                    
                    const targetRect = targetElement.getBoundingClientRect();
                    const targetX = targetRect.left - gameBoardRect.left;
                    let targetYOffset = 0;
                    if (targetInfo.type === 'tableau') {
                        targetInfo.pile.forEach(tc => targetYOffset += (tc.faceUp ? cardVerticalOffset : cardFaceDownOffset));
                    }
                    const targetY = (targetRect.top - gameBoardRect.top) + targetYOffset;

                    let revealedAndFlippedId = null;
                    let autoMoveSourceStartIndex = -1;
                    if (sourceInfo.type === 'tableau') {
                        autoMoveSourceStartIndex = sourceInfo.pile.length - 1;
                        if (sourceInfo.pile.length > 1) {
                            const underlyingCandidate = sourceInfo.pile[sourceInfo.pile.length - 2];
                            if (underlyingCandidate && !underlyingCandidate.faceUp) {
                                revealedAndFlippedId = underlyingCandidate.id;
                            }
                        }
                    }
                    
                    const cardDataForHistory = {...card, element: null};

                    animateCardMoves([{ element: cardElement, startX, startY, targetX, targetY, duration: 200 }], () => {
                        let cardRemoved = false;
                        if (sourceInfo.type === 'waste' && waste.length > 0 && waste[waste.length - 1].id === card.id) {
                            waste.pop(); cardRemoved = true;
                        } else if (sourceInfo.type === 'tableau') {
                            const sourcePile = sourceInfo.pile;
                            if (sourcePile.length > 0 && sourcePile[sourcePile.length - 1].id === card.id) {
                                sourcePile.pop(); cardRemoved = true;
                                if (sourcePile.length > 0) {
                                    const underlying = sourcePile[sourcePile.length - 1];
                                    if (underlying && !underlying.faceUp) {
                                        underlying.faceUp = true;
                                        updateCardElementVisuals(underlying);
                                    }
                                }
                            }
                        }

                        if (cardRemoved) {
                            targetInfo.pile.push(card);
                                recordMove({
                                    type: 'auto_cards_moved',
                                    movedCardData: cardDataForHistory,
                                    originalSource: { id: sourceInfo.element.id, type: sourceInfo.type, pileIndex: sourceInfo.index, startIndexInPile: autoMoveSourceStartIndex },
                                    originalTarget: { id: targetInfo.element.id, type: targetInfo.type, pileIndex: targetInfo.index },
                                    cardFlippedDownInSource: revealedAndFlippedId
                                });
                            renderGame();
                            setTimeout(() => performAutoMovePass(onPassComplete), 50);
                        } else {
                            renderGame();
                            onPassComplete(false);
                        }
                    });
                };

                // Check waste to foundations
                if (waste.length > 0) {
                    const card = waste[waste.length - 1];
                    const sourceInfo = { type: 'waste', pile: waste, element: wastePileEl };
                    for (let i = 0; i < foundations.length; i++) {
                        const targetInfo = { type: 'foundation', pile: foundations[i], index: i, element: foundationPileEls[i] };
                        if (isValidMove(card, sourceInfo, targetInfo)) {
                            animateAndContinue(card, sourceInfo, targetInfo); return;
                        }
                    }
                }
                
                // Check tableau to foundations
                for (let t = 0; t < tableau.length; t++) {
                    const sourcePile = tableau[t];
                    if (sourcePile.length > 0) {
                        const card = sourcePile[sourcePile.length - 1];
                        if (card.faceUp) {
                            const sourceInfo = { type: 'tableau', pile: sourcePile, index: t, element: tableauPileEls[t] };
                            for (let f = 0; f < foundations.length; f++) {
                                const targetInfo = { type: 'foundation', pile: foundations[f], index: f, element: foundationPileEls[f] };
                                if (isValidMove(card, sourceInfo, targetInfo)) {
                                    animateAndContinue(card, sourceInfo, targetInfo); return;
                                }
                            }
                        }
                    }
                }
                onPassComplete(false);
            }

            function startAutoMoveSequence() {
                if (draggedCards || isReplaying) return;
                newGameButton.disabled = true;
                autoMoveButton.disabled = true;
                undoButton.disabled = true;
                performAutoMovePass(() => {
                    if (!isReplaying) {
                       newGameButton.disabled = false;
                       autoMoveButton.disabled = false;
                       undoButton.disabled = moveHistory.length === 0;
                    }
                });
            }
            
            function updateCardElementVisuals(card) {
                if (!card || !card.element) return;
                if (card.faceUp) {
                    card.element.classList.remove('face-down');
                } else {
                    card.element.classList.add('face-down');
                }
                if (!card.element.classList.contains('dragging')) card.element.style.zIndex = 'auto';
            }

            function createDeck() {
                deck = [];
                for (const suit of suits) {
                    for (const rank of ranks) {
                        deck.push(createCard(suit, rank));
                    }
                }
            }
            
            function shuffleDeck() {
                // Fisher-Yates shuffle
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }

            function dealGame(forReplay = false) {
                // Stop any running win animation
                if (winAnimationId) {
                    cancelAnimationFrame(winAnimationId);
                    winAnimationId = null;
                    bouncingCards = [];
                }

                // Clear any running animations or timeouts
                if (currentAnimationFrame) cancelAnimationFrame(currentAnimationFrame);
                if (replayTimeout) clearTimeout(replayTimeout);
                winMessageEl.classList.remove('visible');
                isReplaying = false;
                
                if (!forReplay) {
                    createDeck();
                    shuffleDeck();
                }

                stock = [];
                waste = [];
                foundations = Array.from({ length: 4 }, () => []);
                tableau = Array.from({ length: 7 }, () => []);
                gameBoardEl.querySelectorAll('.card').forEach(cardEl => cardEl.remove());

                if (forReplay && initialGameState) {
                    stock = initialGameState.stock.map(cd => createCard(cd.suit, cd.rank));
                    tableau = initialGameState.tableau.map(tPileData =>
                        tPileData.map(cd => {
                            const card = createCard(cd.suit, cd.rank);
                            card.faceUp = cd.faceUp;
                            return card;
                        })
                    );
                } else {
                    let currentDeck = [...deck];
                    for (let i = 0; i < 7; i++) {
                        for (let j = 0; j <= i; j++) {
                            const card = currentDeck.pop();
                            if (card) {
                                card.faceUp = (j === i);
                                tableau[i].push(card);
                            }
                        }
                    }
                    stock = currentDeck;
                    
                    if (!forReplay) {
                        initialGameState = {
                            stock: stock.map(c => ({ suit: c.suit, rank: c.rank })),
                            tableau: tableau.map(tPile =>
                                tPile.map(c => ({ suit: c.suit, rank: c.rank, faceUp: c.faceUp }))
                            )
                        };
                        moveHistory = [];
                    }
                }

                renderGame();
                undoButton.disabled = moveHistory.length === 0;
                newGameButton.disabled = false;
                autoMoveButton.disabled = false;
            }

            function getPileFromElement(element) {
                let current = element;
                while (current && current !== gameBoardEl && current !== document.body) {
                    if (current.classList.contains('pile')) {
                        const id = current.id;
                        if (id === 'stock') return { type: 'stock', pile: stock, element: current };
                        if (id === 'waste') return { type: 'waste', pile: waste, element: current };
                        if (id.startsWith('foundation')) {
                            const index = parseInt(id.split('-')[1]);
                            return { type: 'foundation', pile: foundations[index], index, element: current };
                        }
                        if (id.startsWith('tableau')) {
                            const index = parseInt(id.split('-')[1]);
                            return { type: 'tableau', pile: tableau[index], index, element: current };
                        }
                        return null;
                    }
                    current = current.parentElement;
                }
                return null;
            }

            function findCardInPiles(cardId) {
                if (!cardId) return null;
                const allPiles = [
                    { pile: waste, type: 'waste', el: wastePileEl },
                    ...foundations.map((p, i) => ({ pile: p, type: 'foundation', el: foundationPileEls[i] })),
                    ...tableau.map((p, i) => ({ pile: p, type: 'tableau', el: tableauPileEls[i] })),
                    { pile: stock, type: 'stock', el: stockPileEl }
                ];

                for (const pileInfo of allPiles) {
                    for (let i = 0; i < pileInfo.pile.length; i++) {
                        if (pileInfo.pile[i]?.id === cardId) {
                            return {
                                card: pileInfo.pile[i],
                                index: i,
                                pileInfo: getPileFromElement(pileInfo.el)
                            };
                        }
                    }
                }
                return null;
            }
            
            function isValidMove(cardToMove, sourcePileInfo, targetPileInfo) {
                if (!cardToMove || !sourcePileInfo || !targetPileInfo || sourcePileInfo.element.id === targetPileInfo.element.id) return false;
                
                const targetPile = targetPileInfo.pile;
                const targetType = targetPileInfo.type;

                if (targetType === 'foundation') {
                    if (sourcePileInfo.type === 'stock' || sourcePileInfo.type === 'foundation') return false;
                    if (targetPile.length === 0) return cardToMove.rank === 'A';
                    const topFoundationCard = targetPile[targetPile.length - 1];
                    return topFoundationCard && cardToMove.suit === topFoundationCard.suit && cardToMove.value === topFoundationCard.value + 1;
                }
                
                if (targetType === 'tableau') {
                    if (sourcePileInfo.type === 'stock') return false;
                    if (targetPile.length === 0) return cardToMove.rank === 'K';
                    const topTableauCard = targetPile[targetPile.length - 1];
                    if (!topTableauCard?.faceUp) return false;
                    return cardToMove.color !== topTableauCard.color && cardToMove.value === topTableauCard.value - 1;
                }
                return false;
            }

            function checkWinCondition() {
                const won = foundations.every(pile => pile.length === 13);
                if (won && !isReplaying) {
                    startWinAnimation();
                }
                return won;
            }

            // --- WIN ANIMATION FUNCTIONS ---
            function startWinAnimation() {
                isReplaying = true; // Use this flag to prevent other interactions
                winMessageEl.classList.add('visible');
                autoMoveButton.disabled = true;
                undoButton.disabled = true;
                newGameButton.disabled = false; // Explicitly enable the new game button

                const allCards = foundations.flat().filter(c => c && c.element);
                const gameBoardRect = gameBoardEl.getBoundingClientRect();
                bouncingCards = [];

                allCards.forEach(card => {
                    const cardEl = card.element;
                    const currentRect = cardEl.getBoundingClientRect();
                    const initialX = currentRect.left - gameBoardRect.left;
                    const initialY = currentRect.top - gameBoardRect.top;

                    gameBoardEl.appendChild(cardEl);
                    cardEl.style.position = 'absolute';
                    cardEl.style.left = '0px';
                    cardEl.style.top = '0px';
                    cardEl.style.transform = `translate(${initialX}px, ${initialY}px)`;
                    cardEl.style.zIndex = 2500 + Math.floor(Math.random() * 52);

                    const speed = 1 + Math.random();
                    const angle = Math.random() * 2 * Math.PI;

                    bouncingCards.push({
                        element: cardEl,
                        x: initialX, y: initialY,
                        dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
                        rot: Math.random() * 360, dRot: (Math.random() - 0.5) * 2
                    });
                });

                if (winAnimationId) cancelAnimationFrame(winAnimationId);
                winAnimationLoop();
            }

            function winAnimationLoop() {
                if (!isReplaying) {
                    cancelAnimationFrame(winAnimationId);
                    winAnimationId = null;
                    return;
                }

                const boardWidth = gameBoardEl.clientWidth;
                const boardHeight = gameBoardEl.clientHeight;

                bouncingCards.forEach(card => {
                    const cardWidth = card.element.offsetWidth;
                    const cardHeight = card.element.offsetHeight;

                    card.x += card.dx;
                    card.y += card.dy;
                    card.rot += card.dRot;

                    if (card.x <= 0) { card.x = 0; card.dx *= -1; }
                    else if (card.x + cardWidth >= boardWidth) { card.x = boardWidth - cardWidth; card.dx *= -1; }

                    if (card.y <= 0) { card.y = 0; card.dy *= -1; }
                    else if (card.y + cardHeight >= boardHeight) { card.y = boardHeight - cardHeight; card.dy *= -1; }

                    card.element.style.transform = `translate(${card.x}px, ${card.y}px) rotate(${card.rot}deg)`;
                });

                winAnimationId = requestAnimationFrame(winAnimationLoop);
            }
            // --- END WIN ANIMATION FUNCTIONS ---

            function handleStockClick() {
                if (draggedCards || isReplaying) return;
                
                let move = null;
                if (stock.length > 0) {
                    const card = stock.pop();
                    if (card) {
                        card.faceUp = true;
                        updateCardElementVisuals(card);
                        waste.push(card);
                        move = { type: 'stock_to_waste', cardData: { ...card, element: null } };
                    }
                } else if (waste.length > 0) {
                    const recycledWasteData = waste.map(c => ({ ...c, element: null }));
                    stock = waste.reverse();
                    stock.forEach(card => {
                        card.faceUp = false;
                        updateCardElementVisuals(card);
                    });
                    waste = [];
                    move = { type: 'waste_to_stock', recycledWasteData };
                }
                
                if (move) recordMove(move);
                renderStock();
                renderWaste();
            }

            // --- Rendering Functions ---
            function renderGame() {
                renderStock();
                renderWaste();
                renderFoundations();
                renderTableau();
                if (!isReplaying) checkWinCondition();
            }

            function renderPile(pileEl, cardArray, applyOffsetFn) {
                pileEl.classList.toggle('empty', cardArray.length === 0);
                const currentCardElements = new Set(cardArray.map(c => c.element));
                
                // Remove cards that are no longer in this pile
                Array.from(pileEl.children).forEach(child => {
                    if (child.classList.contains('card') && !currentCardElements.has(child) && !child.classList.contains('dragging')) {
                        child.remove();
                    }
                });

                // Add and position cards
                cardArray.forEach((card, index) => {
                    if (!card || !card.element) return;
                    if (draggedCards && draggedCards.draggedElements.includes(card.element)) return;
                    
                    updateCardElementVisuals(card);
                    applyOffsetFn(card, index, cardArray);
                    
                    if (card.element.parentElement !== pileEl) {
                        pileEl.appendChild(card.element);
                    }
                    if (!card.element.classList.contains('dragging')) {
                        card.element.style.position = 'absolute';
                    }
                });
            }

            function renderStock() {
                const topCard = stock.length > 0 ? [stock[stock.length - 1]] : [];
                renderPile(stockPileEl, topCard, (card) => {
                    card.faceUp = false;
                    updateCardElementVisuals(card);
                    card.element.style.top = '0px';
                    card.element.style.left = '0px';
                    card.element.style.zIndex = 0;
                });
                stockPileEl.classList.toggle('empty', stock.length === 0);
            }

            function renderWaste() {
                const wasteRenderCount = 3;
                const cardHorizontalSpacing = 35;
                const startIdx = Math.max(0, waste.length - wasteRenderCount);
                const visibleWaste = waste.slice(startIdx);
                
                renderPile(wastePileEl, visibleWaste, (card, indexInVisibleArray) => {
                    card.faceUp = true;
                    updateCardElementVisuals(card);
                    card.element.style.top = '0px';
                    const leftOffset = indexInVisibleArray * cardHorizontalSpacing;
                    card.element.style.left = `${leftOffset}px`;
                    card.element.style.zIndex = indexInVisibleArray;
                });
                wastePileEl.classList.toggle('empty', waste.length === 0);
            }

            function renderFoundations() {
                foundationPileEls.forEach((pileEl, i) => {
                    const pile = foundations[i];
                    renderPile(pileEl, pile.slice(-1), (card, index) => {
                        card.faceUp = true;
                        updateCardElementVisuals(card);
                        card.element.style.top = '0px';
                        card.element.style.left = '0px';
                        card.element.style.zIndex = pile.length - 1;
                    });
                });
            }

            function renderTableau() {
                tableauPileEls.forEach((pileEl, i) => {
                    let currentOffset = 0;
                    renderPile(pileEl, tableau[i], (card, cardIndex) => {
                        if (!card.element.classList.contains('dragging')) {
                            card.element.style.left = '0px';
                            card.element.style.top = `${currentOffset}px`;
                            card.element.style.zIndex = cardIndex;
                        }
                        currentOffset += card.faceUp ? cardVerticalOffset : cardFaceDownOffset;
                    });
                });
            }

            // --- Event Handlers ---
            stockPileEl.addEventListener('click', handleStockClick);
            newGameButton.addEventListener('click', () => dealGame(false));
            autoMoveButton.addEventListener('click', startAutoMoveSequence);
            undoButton.addEventListener('click', undoLastMove);
            window.addEventListener('resize', updateCSSVariableOffsets);

            // --- Drag and Drop Functions ---
            function onCardMouseDown(event) {
                if (draggedCards || isReplaying || event.button !== 0) return; // Only main mouse button
                
                const cardElement = event.target.closest('.card');
                if (!cardElement || cardElement.classList.contains('face-down')) return;
                
                const cardId = cardElement.dataset.cardId;
                const cardSearchResult = findCardInPiles(cardId);
                if (!cardSearchResult) return;
                
                const { card, pileInfo, index } = cardSearchResult;
                if (!card.faceUp || pileInfo.type === 'stock') return;

                let cardsToDrag = [];
                let sourcePileIndex = -1;
                
                if (pileInfo.type === 'tableau') {
                    cardsToDrag = pileInfo.pile.slice(index);
                    if (cardsToDrag.every(c => c.faceUp)) {
                        sourcePileIndex = index;
                    } else return;
                } else if (index === pileInfo.pile.length - 1) { // Waste or Foundation
                    cardsToDrag.push(card);
                    sourcePileIndex = index;
                } else return;

                if (cardsToDrag.length === 0) return;
                
                event.preventDefault();
                
                const rect = cardElement.getBoundingClientRect();
                const touch = event.touches ? event.touches[0] : event;
                dragOffsetX = touch.clientX - rect.left;
                dragOffsetY = touch.clientY - rect.top;

                draggedCards = {
                    cards: cardsToDrag,
                    sourcePileId: pileInfo.element.id,
                    sourceIndex: sourcePileIndex,
                    draggedElements: []
                };

                let currentZIndex = 1000;
                cardsToDrag.forEach((c, i) => {
                    if (!c?.element) return;
                    const el = c.element;
                    const relativeOffsetY = (pileInfo.type === 'tableau' && cardsToDrag.length > 1) ? (i * cardVerticalOffset) : 0;
                    el.dataset.dragRelativeTop = relativeOffsetY;
                    
                    if (el.parentElement !== gameBoardEl) {
                        const cardRect = el.getBoundingClientRect();
                        const boardRect = gameBoardEl.getBoundingClientRect();
                        el.style.left = `${cardRect.left - boardRect.left}px`;
                        el.style.top = `${cardRect.top - boardRect.top}px`;
                        gameBoardEl.appendChild(el);
                    }
                    
                    el.classList.add('dragging');
                    el.style.zIndex = currentZIndex + i;
                    el.style.position = 'absolute';
                    draggedCards.draggedElements.push(el);
                });
                
                moveDraggedElements(touch.clientX, touch.clientY);

                document.addEventListener('mousemove', onDocumentMouseMove);
                document.addEventListener('mouseup', onDocumentMouseUp);
                document.addEventListener('touchmove', onDocumentMouseMove, { passive: false });
                document.addEventListener('touchend', onDocumentMouseUp);
            }

            function moveDraggedElements(clientX, clientY) {
                if (!draggedCards?.draggedElements?.length) return;
                const gameBoardRect = gameBoardEl.getBoundingClientRect();
                const newX = clientX - gameBoardRect.left - dragOffsetX;
                const newYBase = clientY - gameBoardRect.top - dragOffsetY;

                draggedCards.draggedElements.forEach(element => {
                    if (!element) return;
                    const relativeTopOffset = parseFloat(element.dataset.dragRelativeTop || 0);
                    element.style.left = `${newX}px`;
                    element.style.top = `${newYBase + relativeTopOffset}px`;
                });
            }

            function onDocumentMouseMove(event) {
                if (!draggedCards) return;
                if (event.type === 'touchmove') event.preventDefault();
                const touch = event.touches ? event.touches[0] : event;
                moveDraggedElements(touch.clientX, touch.clientY);
            }

            function onDocumentMouseUp(event) {
                if (!draggedCards) return;

                draggedCards.draggedElements.forEach(el => { if (el) el.style.pointerEvents = 'none'; });
                const touch = event.changedTouches ? event.changedTouches[0] : event;
                const dropTargetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                draggedCards.draggedElements.forEach(el => { if (el) el.style.pointerEvents = 'auto'; });

                const targetPileInfo = getPileFromElement(dropTargetElement);
                const sourcePileInfo = getPileFromElement(document.getElementById(draggedCards.sourcePileId));
                
                let moveSuccessful = false;
                let revealedAndFlippedId = null;
                const cardsDataForHistory = draggedCards.cards.map(c => ({ ...c, element: null, faceUp: c.faceUp }));

                if (targetPileInfo && sourcePileInfo && isValidMove(draggedCards.cards[0], sourcePileInfo, targetPileInfo)) {
                    const removedCards = sourcePileInfo.pile.splice(draggedCards.sourceIndex, draggedCards.cards.length);
                    targetPileInfo.pile.push(...removedCards);

                    if (sourcePileInfo.type === 'tableau' && sourcePileInfo.pile.length > 0) {
                        const under = sourcePileInfo.pile[sourcePileInfo.pile.length - 1];
                        if (under && !under.faceUp) {
                            under.faceUp = true;
                            updateCardElementVisuals(under);
                            revealedAndFlippedId = under.id;
                        }
                    }
                    moveSuccessful = true;
                }

                if (moveSuccessful) {
                    recordMove({
                        type: 'cards_moved',
                        movedCardsData: cardsDataForHistory,
                        originalSource: { id: sourcePileInfo.element.id, type: sourcePileInfo.type, pileIndex: sourcePileInfo.index, startIndexInPile: draggedCards.sourceIndex },
                        originalTarget: { id: targetPileInfo.element.id, type: targetPileInfo.type, pileIndex: targetPileInfo.index },
                        cardFlippedDownInSource: revealedAndFlippedId
                    });
                }

                const recentlyDraggedElements = draggedCards.draggedElements;
                draggedCards = null;
                
                document.removeEventListener('mousemove', onDocumentMouseMove);
                document.removeEventListener('mouseup', onDocumentMouseUp);
                document.removeEventListener('touchmove', onDocumentMouseMove);
                document.removeEventListener('touchend', onDocumentMouseUp);

                recentlyDraggedElements.forEach(el => {
                    if (!el) return;
                    el.classList.remove('dragging');
                    el.style.zIndex = 'auto';
                    el.style.top = '';
                    el.style.left = '';
                    el.style.position = '';
                    delete el.dataset.dragRelativeTop;
                });
                
                renderGame();
            }

            // --- Undo Functions ---
            function recordMove(moveDetails) {
                if (isReplaying) return;
                moveHistory.push(JSON.parse(JSON.stringify(moveDetails)));
                undoButton.disabled = false;
            }

            function getPileData(pileId) {
                if (pileId === 'stock') return stock;
                if (pileId === 'waste') return waste;
                if (pileId.startsWith('foundation-')) return foundations[parseInt(pileId.split('-')[1])];
                if (pileId.startsWith('tableau-')) return tableau[parseInt(pileId.split('-')[1])];
                return null;
            }

            function findCardObjectInGame(cardId) {
                const allPilesData = [stock, waste, ...foundations, ...tableau];
                for (const pile of allPilesData) {
                    const found = pile.find(card => card.id === cardId);
                    if (found) return found;
                }
                return null;
            }

            function undoLastMove() {
                if (moveHistory.length === 0 || isReplaying) return;
                
                const lastMove = moveHistory.pop();
                
                if (lastMove.type === 'cards_moved' || lastMove.type === 'auto_cards_moved') {
                    const sourceDataPile = getPileData(lastMove.originalSource.id);
                    const targetDataPile = getPileData(lastMove.originalTarget.id);
                    const cardsToRestoreData = lastMove.type === 'cards_moved' ? lastMove.movedCardsData : [lastMove.movedCardData];
                    
                    if (!sourceDataPile || !targetDataPile) return;

                    const removedCardObjects = targetDataPile.splice(targetDataPile.length - cardsToRestoreData.length, cardsToRestoreData.length);
                    
                    removedCardObjects.forEach((cardObj, index) => {
                        cardObj.faceUp = cardsToRestoreData[index].faceUp;
                    });
                    
                    const insertIndex = lastMove.originalSource.startIndexInPile;
                     if (lastMove.originalSource.type === 'tableau' && typeof insertIndex === 'number' && insertIndex > -1) {
                        sourceDataPile.splice(insertIndex, 0, ...removedCardObjects);
                    } else { 
                        sourceDataPile.push(...removedCardObjects);
                    }
                    
                    if (lastMove.cardFlippedDownInSource) {
                        const cardToFlip = findCardObjectInGame(lastMove.cardFlippedDownInSource);
                        if (cardToFlip) {
                            cardToFlip.faceUp = false;
                            updateCardElementVisuals(cardToFlip);
                        }
                    }
                } else if (lastMove.type === 'stock_to_waste') {
                    const cardToMoveBack = waste.pop();
                    if (cardToMoveBack) {
                        cardToMoveBack.faceUp = false;
                        updateCardElementVisuals(cardToMoveBack);
                        stock.push(cardToMoveBack);
                    }
                } else if (lastMove.type === 'waste_to_stock') {
                    waste = stock.reverse();
                    waste.forEach(card => {
                        card.faceUp = true;
                        updateCardElementVisuals(card);
                    });
                    stock = [];
                }
                
                if(winMessageEl.classList.contains('visible')) {
                    winMessageEl.classList.remove('visible');
                }
                
                undoButton.disabled = moveHistory.length === 0;
                renderGame();
            }

            // --- Initial Game Start ---
            updateCSSVariableOffsets();
            dealGame(false);
        });
    </script>
</body>
</html>