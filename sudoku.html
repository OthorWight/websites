<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Generator</title>
    <style>
        /* --- General Styling --- */
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align top for longer content */
            min-height: 100vh;
            background-color: #f0f0f0;
            padding-top: 20px; /* Add some space at the top */
            padding-bottom: 40px; /* Add space at bottom */
        }

        .container {
            text-align: center;
            background-color: #fff;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        h1 {
            margin-top: 0;
            color: #333;
        }

        /* --- Controls --- */
        .controls {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px; /* Spacing between control elements */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .controls label,
        .controls select,
        .controls button {
            padding: 8px 12px;
            font-size: 1em;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .controls select {
            cursor: pointer;
        }
        .controls button {
            cursor: pointer;
            background-color: #e7e7e7;
            transition: background-color 0.2s;
        }
        .controls button:hover {
            background-color: #d7d7d7;
        }
        .controls button#new-game-btn {
            background-color: #4CAF50; /* Green */
            color: white;
            border-color: #4CAF50;
        }
        .controls button#new-game-btn:hover {
            background-color: #45a049;
        }


        /* --- Sudoku Grid --- */
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            /* Responsive width, max-width */
            width: clamp(300px, 90vmin, 450px);
            height: clamp(300px, 90vmin, 450px);
            border: 3px solid #333;
            margin: 20px auto;
            box-sizing: border-box;
        }

        .cell {
            position: relative; /* Needed for absolute positioning of value/notes */
            border: 1px solid #ccc;
            box-sizing: border-box;
            display: flex; /* Use flex for centering value later */
            justify-content: center;
            align-items: center;
            cursor: pointer;
            background-color: #fff;
            transition: background-color 0.2s;
        }

        /* Add thicker lines for 3x3 boxes */
        /* Using :nth-child is often more robust than data attributes for this */
        .cell:nth-child(9n) { border-right: 3px solid #333; } /* Right edge of grid */
        .cell:nth-child(n):nth-child(-n+9) { border-top: 3px solid #333; } /* Top edge of grid */
        .cell:nth-child(n+73) { border-bottom: 3px solid #333; } /* Bottom edge of grid */
        .cell:nth-child(9n+1) { border-left: 3px solid #333; } /* Left edge of grid */

        .cell:nth-child(3n) { border-right: 2px solid #555; }
        .cell:nth-child(9n+1), .cell:nth-child(9n+4), .cell:nth-child(9n+7) { border-left: 2px solid #555; } /* Thick left lines for boxes */
        .cell:nth-child(n+19):nth-child(-n+27), .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid #555; } /* Thick bottom lines for boxes */


        .cell.selected {
            background-color: #e0f7fa; /* Light blue highlight for selected cell */
        }

        .cell.highlight {
            background-color: #f0f0f0; /* Subtle highlight for related cells */
        }
        .cell.highlight.selected { /* Ensure selected wins over highlight */
            background-color: #e0f7fa;
        }

        .cell.initial { /* Style for pre-filled numbers */
            background-color: #eee;
            font-weight: bold;
            /* Make initial cells clickable in custom mode if needed, but style differently */
            /* cursor: default; REMOVED - all cells clickable now */
        }

        /* Style for cells with numbers violating Sudoku rules (duplicates) */
        .cell.conflicting {
            background-color: #ffebee; /* Light red background for conflict */
        }
        /* Style the *number* within conflicting cells red (unless initial) */
        .cell.conflicting:not(.initial) .value { /* Keep initial styling separate */
            color: #b71c1c; /* Darker red for rule conflict */
        }

        /* Style for user-entered numbers that are simply wrong vs the solution */
        /* This style might not be used in 'custom' mode */
        .cell:not(.initial).user-wrong .value {
            color: #d32f2f; /* Regular red for wrong number */
        }
        /* If a cell is BOTH conflicting AND wrong, ensure the number stays red */
        .cell.conflicting:not(.initial).user-wrong .value {
            color: #b71c1c; /* Prioritize darker red if also a rule conflict */
        }


        /* --- Notes Grid --- */
        .notes-grid {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr); /* Ensure 3 rows */
            width: 100%;
            height: 100%;
            padding: 1px; /* Small padding */
            box-sizing: border-box;
            pointer-events: none; /* Prevent notes from interfering with cell clicks */
        }

        .note-cell {
            font-size: clamp(0.5em, 2vmin, 0.7em); /* Responsive font size */
            color: #aaa;
            display: flex;
            justify-content: center;
            align-items: center;
            visibility: hidden; /* Notes are hidden by default */
            line-height: 1;
            font-weight: normal; /* Ensure notes aren't bold */
        }

        .note-cell.visible {
            visibility: visible; /* Make specific notes visible */
        }

        .note-cell.hidden-single {
            font-weight: bold;
            color: #666;
        }

        /* --- Cell Value --- */
        .value {
            position: absolute; /* Take it out of flow relative to notes */
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.5em, 5vmin, 2em); /* Responsive font size */
            color: #007bff; /* Default blue for user-entered values */
            z-index: 1; /* Ensure value is above notes */
            pointer-events: none; /* Prevent value div from interfering */
        }

        /* Different color for initial numbers - used in non-custom modes */
        .cell.initial .value {
            color: #333; /* Black */
        }

        /* --- Number Pad --- */
        .number-pad {
            margin-top: 20px;
            display: flex; /* Arrange buttons in a row */
            justify-content: center; /* Center buttons */
            flex-wrap: wrap; /* Allow wrapping */
            gap: 5px; /* Spacing between buttons */
        }

        .num-btn {
            font-size: clamp(1em, 3vmin, 1.2em);
            width: clamp(35px, 9vmin, 45px);
            height: clamp(35px, 9vmin, 45px);
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f8f8f8;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
        }

        .num-btn.selected {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .num-btn:not(.selected):hover {
            background-color: #e0e0e0;
        }

        .num-btn.selected:hover {
            background-color: #0056b3;
        }

        .num-btn.erase { /* Style for erase button */
            background-color: #fdd;
            color: #d32f2f;
            border-color: #fbc;
        }
        .num-btn.erase.selected { /* Erase can also be 'selected' */
            background-color: #d32f2f;
            color: white;
            border-color: #b71c1c;
        }
        .num-btn.erase:not(.selected):hover {
            background-color: #fbb;
        }
        .num-btn.erase.selected:hover {
            background-color: #b71c1c;
        }

        /* --- Status Message --- */
        #status-message {
            margin-top: 15px;
            font-weight: bold;
            min-height: 1.2em; /* Prevent layout shifts */
            color: #4CAF50; /* Green for success */
        }

        /* --- Disabled Number Button Styling --- */
        .num-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f0f0f0; /* More muted background */
            color: #aaa; /* Lighter text */
            border-color: #ddd;
        }
        /* Ensure hover effect doesn't apply when disabled */
        .num-btn:disabled:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sudoku</h1>

        <div class="controls">
            <label for="difficulty">Difficulty:</label>
            <select id="difficulty">
                <option value="easy">Easy</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Hard</option>
                <option value="expert">Expert</option>
                <option value="custom">Custom</option> <!-- Added Custom Option -->
            </select>
            <button id="new-game-btn">New Game</button>
        </div>

        <div id="sudoku-grid" class="sudoku-grid">
            <!-- 81 cells will be generated here by JavaScript -->
        </div>

        <div id="number-pad" class="number-pad">
            <button class="num-btn" data-number="1">1</button>
            <button class="num-btn" data-number="2">2</button>
            <button class="num-btn" data-number="3">3</button>
            <button class="num-btn" data-number="4">4</button>
            <button class="num-btn" data-number="5">5</button>
            <button class="num-btn" data-number="6">6</button>
            <button class="num-btn" data-number="7">7</button>
            <button class="num-btn" data-number="8">8</button>
            <button class="num-btn" data-number="9">9</button>
            <button class="num-btn erase" data-number="0">Erase</button>
        </div>

        <p id="status-message"></p> <!-- For messages like "Solved!" -->

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridElement = document.getElementById('sudoku-grid');
            const numberPad = document.getElementById('number-pad');
            const difficultySelect = document.getElementById('difficulty');
            const newGameBtn = document.getElementById('new-game-btn');
            const statusMessage = document.getElementById('status-message');

            const SIZE = 9;
            const BOX_SIZE = 3;

            let currentGrid = []; // Current state including user input
            let solvedGrid = [];  // The complete hidden solution (empty in custom mode)
            let initialGrid = []; // The initial puzzle state (all 0s in custom mode)
            let selectedCell = null; // { row, col, element }
            let selectedNumber = null; // Number (1-9) or 0 for erase
            let isGenerating = false; // Flag to prevent clicks during generation
            let isCustomMode = false; // Flag for custom mode

            const difficultySettings = {
                easy: 45,
                normal: 36,
                hard: 28,
                expert: 22,
                // Custom doesn't need a number here, handled separately
            };

            // <<< --- START OF MISSING/INSERTED FUNCTIONS --- >>>

            /**
             * Shuffles array elements in place using the Fisher-Yates algorithm.
             * @param {Array} array The array to shuffle.
             * @returns {Array} The shuffled array (same instance).
             */
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]]; // ES6 swap
                }
                return array;
            }

            /**
             * Counts the number of solutions for a given Sudoku grid using backtracking.
             * Stops early if more than one solution is found.
             * IMPORTANT: Modifies the grid passed! Pass a copy if original needs preservation.
             * @param {number[][]} grid - The Sudoku grid (potentially partial).
             * @returns {number} 0, 1, or 2 (representing "2 or more").
             */
            function countSolutions(grid) {
                let count = 0;

                function solve() {
                    const find = findEmpty(grid);
                    if (!find) {
                        count++; // Found a solution
                        return; // Continue searching if count < 2
                    }

                    const [row, col] = find;
                    for (let num = 1; num <= SIZE && count < 2; num++) { // Stop early
                        if (isValid(grid, row, col, num)) {
                            grid[row][col] = num;
                            solve(); // Recurse
                            if (count >= 2) {
                                grid[row][col] = 0; // Backtrack mandatory before returning
                                return;
                            }
                            grid[row][col] = 0; // Backtrack for next num/state
                        }
                    }
                }
                // Create a deep copy to avoid modifying the original grid passed
                let gridCopy = grid.map(row => [...row]);
                solve(); // Call solve on the copy
                return count; // 0, 1, or 2
            }


            // <<< --- END OF MISSING/INSERTED FUNCTIONS --- >>>


            // --- Core Sudoku Setup Logic ---

            function setupNewGame() {
                if (isGenerating) return;
                isGenerating = true;
                clearSelection();
                gridElement.style.opacity = '0.5';

                const selectedDifficulty = difficultySelect.value;
                isCustomMode = (selectedDifficulty === 'custom'); // Set the custom mode flag

                if (isCustomMode) {
                    statusMessage.textContent = "Custom Mode: Fill the grid.";
                    setupCustomGrid();
                } else {
                    statusMessage.textContent = `Generating ${selectedDifficulty} puzzle...`;
                    generatePuzzle(); // Call the puzzle generation function
                }
            }

            function setupCustomGrid() {
                 // No generation needed, just setup empty grids
                 setTimeout(() => {
                    console.log("Setting up Custom Grid");
                    currentGrid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
                    initialGrid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0)); // All cells are user-editable
                    solvedGrid = []; // No solution to check against

                    renderGrid(); // Render the empty grid
                    updateAllNotes();
                    updateHiddenSingleNotes();
                    updateNumberPadState(); // Ensure buttons aren't disabled based on count
                    statusMessage.textContent = "Custom Mode: Fill the grid."; // Set specific message
                    gridElement.style.opacity = '1';
                    isGenerating = false;
                    console.log("Custom Grid Ready.");
                 }, 10); // Small delay for UI update
            }


            function generatePuzzle() {
                // This function now only handles standard puzzle generation
                setTimeout(() => {
                    console.time("Sudoku Generation");
                    let grid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
                    if (!fillGrid(grid)) { // Check if filling was successful
                        console.error("Failed to generate a fully solved grid.");
                        statusMessage.textContent = "Error generating puzzle. Try again.";
                        gridElement.style.opacity = '1';
                        isGenerating = false;
                        return;
                    }
                    solvedGrid = grid.map(row => [...row]); // Store the full solution

                    const difficulty = difficultySelect.value;
                    const cellsToKeep = difficultySettings[difficulty] || difficultySettings.normal;
                    currentGrid = pokeHoles(solvedGrid, cellsToKeep); // Create puzzle
                    initialGrid = currentGrid.map(row => [...row]); // Store initial state

                    console.timeEnd("Sudoku Generation");

                    renderGrid(); // Initial render
                    updateAllNotes();
                    updateHiddenSingleNotes();
                    updateNumberPadState();
                    statusMessage.textContent = ""; // Clear generating message
                    gridElement.style.opacity = '1';
                    isGenerating = false;
                }, 50); // Delay allows UI update for "Generating..." message
            }

            // --- Sudoku Generation Helpers (fillGrid, findEmpty, isValid, pokeHoles) ---
            // These remain largely the same, but pokeHoles needs the updated countSolutions

            function fillGrid(grid) {
                const find = findEmpty(grid);
                if (!find) return true; // Grid full
                const [row, col] = find;
                const numbers = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]); // Use shuffle
                for (let num of numbers) {
                    // Check validity against the *current* state of the grid being built
                    if (isValidForGeneration(grid, row, col, num)) {
                        grid[row][col] = num;
                        if (fillGrid(grid)) return true; // Solution found
                        grid[row][col] = 0; // Backtrack
                    }
                }
                return false; // No valid number found
            }

            function findEmpty(grid) {
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        if (grid[r][c] === 0) return [r, c];
                    }
                }
                return null; // No empty cell
            }

             // Helper for fillGrid - checks placement rules strictly
            function isValidForGeneration(grid, row, col, num) {
                // Check row
                for (let c = 0; c < SIZE; c++) {
                    if (grid[row][c] === num) return false;
                }
                // Check column
                for (let r = 0; r < SIZE; r++) {
                    if (grid[r][col] === num) return false;
                }
                // Check box
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let r = startRow; r < startRow + BOX_SIZE; r++) {
                    for (let c = startCol; c < startCol + BOX_SIZE; c++) {
                        if (grid[r][c] === num) return false;
                    }
                }
                return true; // Number is valid for this placement during generation
            }


            // isValid checks if a number *currently* conflicts with others (for UI feedback)
            // It allows checking a cell against itself to see if IT is the source of conflict elsewhere
            function isValid(grid, row, col, num) {
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let i = 0; i < SIZE; i++) {
                    // Check row (excluding self)
                    if (grid[row][i] === num && i !== col) return false;
                    // Check column (excluding self)
                    if (grid[i][col] === num && i !== row) return false;
                    // Check box (excluding self)
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    if (grid[boxR][boxC] === num && (boxR !== row || boxC !== col)) return false;
                }
                return true;
            }

            function pokeHoles(solvedGridInput, cellsToKeep) {
                let puzzleGrid = solvedGridInput.map(row => [...row]);
                let cellsRemoved = 0;
                const targetCellsToRemove = SIZE * SIZE - cellsToKeep;

                let candidates = [];
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        candidates.push([r, c]);
                    }
                }
                shuffle(candidates);

                console.log(`Target clues: ${cellsToKeep}. Attempting to remove ${targetCellsToRemove} cells...`);

                for (let i = 0; i < candidates.length && cellsRemoved < targetCellsToRemove; i++) {
                    const [r, c] = candidates[i];
                    if (puzzleGrid[r][c] === 0) continue; // Already removed

                    let backup = puzzleGrid[r][c];
                    puzzleGrid[r][c] = 0; // Tentatively remove

                    // MUST pass a copy to countSolutions as it modifies the grid
                    let gridCopyForCheck = puzzleGrid.map(row => [...row]);
                    let numberOfSolutions = countSolutions(gridCopyForCheck); // Use updated countSolutions

                    if (numberOfSolutions !== 1) {
                        puzzleGrid[r][c] = backup; // Put back if not unique
                    } else {
                        cellsRemoved++; // Keep removed
                    }
                }
                console.log(`Successfully removed ${cellsRemoved} cells. Final clues: ${SIZE*SIZE - cellsRemoved}`);
                if (cellsRemoved < targetCellsToRemove) {
                    console.warn(`Could not remove target number of cells. Target: ${targetCellsToRemove}, Removed: ${cellsRemoved}`);
                }
                return puzzleGrid;
            }

            // --- DOM Manipulation & Rendering ---

            function createGridDOM() {
                gridElement.innerHTML = '';
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        const notesGrid = document.createElement('div');
                        notesGrid.classList.add('notes-grid');
                        for (let n = 1; n <= SIZE; n++) {
                            const noteCell = document.createElement('div');
                            noteCell.classList.add('note-cell');
                            noteCell.dataset.note = n;
                            noteCell.textContent = n;
                            notesGrid.appendChild(noteCell);
                        }
                        cell.appendChild(notesGrid);

                        const valueDiv = document.createElement('div');
                        valueDiv.classList.add('value');
                        cell.appendChild(valueDiv);

                        cell.addEventListener('click', handleCellClick);
                        gridElement.appendChild(cell);
                    }
                }
            }

            function renderGrid() {
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        const cellElement = getCellElement(r, c);
                        if (!cellElement) continue;
                        const valueDiv = cellElement.querySelector('.value');
                        const notesGrid = cellElement.querySelector('.notes-grid');
                        const value = currentGrid[r][c];

                        // Reset dynamic classes
                        cellElement.classList.remove('initial', 'conflicting', 'selected', 'highlight', 'user-wrong');
                        valueDiv.textContent = '';
                        notesGrid.style.display = 'grid'; // Default show notes grid

                        if (value !== 0) {
                            valueDiv.textContent = value;
                            notesGrid.style.display = 'none'; // Hide notes if value exists

                            // Apply 'initial' style only if NOT in custom mode and cell was pre-filled
                            if (!isCustomMode && initialGrid[r][c] !== 0) {
                                cellElement.classList.add('initial');
                            } else {
                                // User-entered number (or any number in custom mode)
                                // Check correctness vs solution ONLY if NOT in custom mode
                                if (!isCustomMode && solvedGrid.length > 0 && value !== solvedGrid[r][c]) {
                                    cellElement.classList.add('user-wrong');
                                }
                            }
                        } else {
                            notesGrid.style.display = 'grid'; // Ensure notes grid shown for empty
                        }
                    }
                }
                // Re-apply selection/highlighting after main loop
                if (selectedCell) {
                    highlightAffectedCells(selectedCell.row, selectedCell.col);
                    getCellElement(selectedCell.row, selectedCell.col)?.classList.add('selected');
                }
                // Check rule conflicts (duplicates) after rendering values
                checkAllConflicts();
            }

            // --- Notes Logic (updateCellNotes, updateAllNotes, getPossibleNumbers) ---
            // These functions work based on currentGrid, so they should be fine for custom mode.

            function updateCellNotes(row, col) {
                const cellElement = getCellElement(row, col);
                if (!cellElement) return;
                const notesGrid = cellElement.querySelector('.notes-grid');
                if (!notesGrid) return;

                if (currentGrid[row][col] !== 0) {
                    notesGrid.style.display = 'none'; // Hide notes if cell has value
                    notesGrid.querySelectorAll('.note-cell').forEach(nc => nc.classList.remove('visible', 'hidden-single')); // Clear visibility and style
                    return;
                } else {
                    notesGrid.style.display = 'grid'; // Show notes grid if cell is empty
                }

                const possible = getPossibleNumbers(currentGrid, row, col);
                for (let n = 1; n <= SIZE; n++) {
                    const noteCell = notesGrid.querySelector(`.note-cell[data-note='${n}']`);
                    if (!noteCell) continue;
                    noteCell.classList.toggle('visible', possible.includes(n)); // Add/remove 'visible'
                    noteCell.classList.remove('hidden-single'); // Reset hidden single state here
                }
            }

            function updateAllNotes() {
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        updateCellNotes(r, c); // Update notes based on current grid state
                    }
                }
                 // After updating basic visibility, check for hidden singles
                 updateHiddenSingleNotes();
            }


            function getPossibleNumbers(grid, row, col) {
                if (grid[row][col] !== 0) return []; // No possibilities if filled
                let possible = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;

                for (let i = 0; i < SIZE; i++) {
                    if (grid[row][i] !== 0) possible.delete(grid[row][i]); // Row check
                    if (grid[i][col] !== 0) possible.delete(grid[i][col]); // Col check
                    // Box check
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    if (grid[boxR][boxC] !== 0) possible.delete(grid[boxR][boxC]);
                }
                return Array.from(possible);
            }

            // --- Event Handlers ---

            function handleCellClick(event) {
                if (isGenerating) return;
                const cell = event.currentTarget;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                // In standard modes, prevent input on initial cells. Allow selection.
                // In custom mode, ALL cells are editable.
                if (!isCustomMode && initialGrid[row][col] !== 0) {
                    selectCell(row, col, cell); // Select initial cell for highlighting only
                    return; // Don't allow input
                }

                // If a number is pre-selected on the numpad, place it immediately
                if (selectedNumber !== null) {
                    placeNumberInCell(row, col, selectedNumber);
                } else {
                    // Otherwise, just select the cell
                    selectCell(row, col, cell);
                }
            }

            function handleNumberClick(event) {
                if (isGenerating) return;
                const button = event.currentTarget;
                if (button.disabled) return; // Ignore disabled button clicks

                const number = parseInt(button.dataset.number);

                if (selectedNumber === number) {
                    clearSelection(); // Toggle off if same number clicked
                    return;
                }

                selectNumber(number, button); // Select the number

                // If a cell is selected, place the number immediately (ensure cell is editable)
                if (selectedCell) {
                    // Check if the selected cell is editable (always true in custom mode)
                    if (isCustomMode || initialGrid[selectedCell.row][selectedCell.col] === 0) {
                         placeNumberInCell(selectedCell.row, selectedCell.col, number);
                    }
                }
            }

            function handleKeyDown(event) {
                if (isGenerating || !selectedCell) return; // Ignore if no cell selected or generating

                const { row, col } = selectedCell;

                 // Check if cell is editable (always true in custom mode)
                 if (!isCustomMode && initialGrid[row][col] !== 0) {
                    // Allow navigation even on initial cells
                    if (event.key.startsWith('Arrow')) {
                         moveSelection(event.key);
                         event.preventDefault();
                    }
                    return; // Ignore number input on initial cells in non-custom mode
                 }


                let number = null;
                if (event.key >= '1' && event.key <= '9') {
                    number = parseInt(event.key);
                } else if (event.key === 'Backspace' || event.key === 'Delete' || event.key === '0') {
                    number = 0; // Erase
                } else if (event.key.startsWith('Arrow')) {
                    moveSelection(event.key); // Handle arrow key navigation
                    event.preventDefault(); // Prevent page scroll
                    return; // Don't place number
                }

                if (number !== null) {
                    event.preventDefault(); // Prevent default key action

                    // Check if corresponding number button is disabled (only in non-custom mode)
                    const numBtn = numberPad.querySelector(`.num-btn[data-number='${number}']`);
                    if (!isCustomMode && number !== 0 && numBtn && numBtn.disabled) {
                        console.log(`Number ${number} is complete.`);
                        return; // Don't place completed numbers in non-custom mode
                    }
                    placeNumberInCell(row, col, number); // Place the number
                }
            }

            // handleNewGame is now replaced by setupNewGame
            // newGameBtn.addEventListener('click', setupNewGame);
            // difficultySelect.addEventListener('change', setupNewGame);


            // --- Core Interaction Logic ---

            function placeNumberInCell(row, col, number) {
                 // Double check editability (redundant check, but safe)
                 if (!isCustomMode && initialGrid[row][col] !== 0) return;

                const currentValue = currentGrid[row][col];
                // Determine new value (0 if erasing or toggling off same number)
                const newValue = (number === 0 || (number !== 0 && number === currentValue)) ? 0 : number;

                if (currentGrid[row][col] !== newValue) { // Only proceed if value changes
                    currentGrid[row][col] = newValue; // Update internal grid state

                    const cellElement = getCellElement(row, col);
                    const valueDiv = cellElement.querySelector('.value');
                    const notesGrid = cellElement.querySelector('.notes-grid');

                    // Update visual state of the cell
                    cellElement.classList.remove('user-wrong'); // Remove wrong state before re-evaluating
                    if (newValue !== 0) {
                        valueDiv.textContent = newValue;
                        notesGrid.style.display = 'none';
                        cellElement.classList.remove('initial'); // Ensure initial class is removed if user writes

                        // Check correctness against the solved grid ONLY if NOT in custom mode
                        if (!isCustomMode && solvedGrid.length > 0 && newValue !== solvedGrid[row][col]) {
                            cellElement.classList.add('user-wrong');
                        }
                    } else {
                        // Erasing the cell
                        valueDiv.textContent = '';
                        notesGrid.style.display = 'grid'; // Show notes grid again
                        updateCellNotes(row, col); // Update notes for the now empty cell
                    }

                    // Update surrounding elements and game state
                    updateNotesInAffectedCells(row, col); // Update notes in row/col/box
                    updateHiddenSingleNotes(); // Re-check hidden singles after change
                    checkAllConflicts(); // Check for Sudoku rule violations (duplicates)
                    updateNumberPadState(); // Enable/disable number buttons

                    // Check win condition only if not in custom mode
                    if (!isCustomMode) {
                        checkWinCondition();
                    } else {
                        statusMessage.textContent = "Custom Mode: Fill the grid."; // Keep custom message
                    }
                }
                // Keep the cell selected after placement
                selectCell(row, col, getCellElement(row, col));
            }

            // --- Helper Functions (getCellElement, Selection, Highlighting, Conflicts, Win Condition) ---

            function getCellElement(row, col) {
                return gridElement.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            }

            function selectCell(row, col, element) {
                if (!element) return; // Safety check
                clearSelectionVisually(); // Clear previous selection visuals
                selectedCell = { row, col, element };
                element.classList.add('selected'); // Highlight the cell
                highlightAffectedCells(row, col); // Highlight related cells/numbers
                // Keep number pad selection if active
                if (selectedNumber !== null) {
                    const numBtn = numberPad.querySelector(`.num-btn[data-number='${selectedNumber}']`);
                    if (numBtn) numBtn.classList.add('selected');
                }
            }

            function selectNumber(number, element) {
                numberPad.querySelectorAll('.num-btn').forEach(btn => btn.classList.remove('selected')); // Clear others
                if (element) element.classList.add('selected'); // Highlight selected button
                selectedNumber = number; // Store selected number state
            }

            function clearSelectionVisually() {
                // Clear cell selection visuals
                if (selectedCell) {
                    selectedCell.element.classList.remove('selected');
                }
                gridElement.querySelectorAll('.cell.highlight').forEach(cell => cell.classList.remove('highlight'));
                // Clear number pad selection visual
                numberPad.querySelectorAll('.num-btn').forEach(btn => btn.classList.remove('selected'));
            }

            function clearSelection() {
                clearSelectionVisually(); // Clear visuals
                selectedCell = null; // Reset internal state
                selectedNumber = null; // Reset internal state
            }

            function highlightAffectedCells(row, col) {
                // Clear previous highlights
                gridElement.querySelectorAll('.cell.highlight').forEach(cell => cell.classList.remove('highlight'));
                const currentVal = currentGrid[row][col]; // Value in the selected cell

                // Highlight row, column, and box
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let i = 0; i < SIZE; i++) {
                    getCellElement(row, i)?.classList.add('highlight'); // Row
                    getCellElement(i, col)?.classList.add('highlight'); // Col
                    // Box
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    getCellElement(boxR, boxC)?.classList.add('highlight');
                }

                // Highlight cells with the same number (if selected cell has a number)
                if (currentVal !== 0) {
                    for (let r = 0; r < SIZE; r++) {
                        for (let c = 0; c < SIZE; c++) {
                            if (currentGrid[r][c] === currentVal) {
                                getCellElement(r, c)?.classList.add('highlight');
                            }
                        }
                    }
                }
            }

             function updateNotesInAffectedCells(row, col) {
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                const cellsToUpdate = new Set(); // Use Set to avoid duplicates
                for (let i = 0; i < SIZE; i++) {
                    cellsToUpdate.add(`${row}-${i}`); // Row
                    cellsToUpdate.add(`${i}-${col}`); // Column
                    // Box
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    cellsToUpdate.add(`${boxR}-${boxC}`);
                }
                // Update notes only for affected cells
                cellsToUpdate.forEach(coord => {
                    const [r, c] = coord.split('-').map(Number);
                    updateCellNotes(r, c); // This updates visibility
                });
                // After updating visibility for all affected cells, re-check for hidden singles globally or locally
                 updateHiddenSingleNotes(); // It's simpler to just re-run the global check
            }


            /** Checks for Sudoku rule violations (duplicates) */
            function checkAllConflicts() {
                // Clear previous rule conflicts
                gridElement.querySelectorAll('.cell.conflicting').forEach(cell => cell.classList.remove('conflicting'));
                let hasRuleConflict = false;
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        const value = currentGrid[r][c];
                        if (value !== 0) {
                            // Check if placing 'value' at [r,c] violates rules against other numbers
                            if (!isValid(currentGrid, r, c, value)) {
                                // Mark cells involved in the conflict (could be multiple)
                                markRuleConflict(r, c, value); // Mark all involved cells
                                hasRuleConflict = true;
                            }
                        }
                    }
                }
                return hasRuleConflict;
            }

            /** Marks all cells involved in a rule conflict for a given number */
            function markRuleConflict(row, col, num) {
                const cellElement = getCellElement(row, col);
                // Mark the cell itself if it's part of a conflict
                // Check if 'num' exists elsewhere causing the conflict for this cell
                if (!isValid(currentGrid, row, col, num)) {
                    cellElement?.classList.add('conflicting');
                }

                // Mark others in row/col/box with same number causing conflict
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for(let i=0; i<SIZE; i++) {
                    // Row Check: Mark other cell if it has the same number
                    if (i !== col && currentGrid[row][i] === num) getCellElement(row, i)?.classList.add('conflicting');
                    // Col Check: Mark other cell if it has the same number
                    if (i !== row && currentGrid[i][col] === num) getCellElement(i, col)?.classList.add('conflicting');
                    // Box Check: Mark other cell if it has the same number
                    const boxR = startRow + Math.floor(i / BOX_SIZE);
                    const boxC = startCol + (i % BOX_SIZE);
                    if ((boxR !== row || boxC !== col) && currentGrid[boxR][boxC] === num) {
                        getCellElement(boxR, boxC)?.classList.add('conflicting');
                    }
                }
            }


            /** Checks if the grid is full and matches the solution - Not applicable in Custom Mode */
            function checkWinCondition() {
                 if (isCustomMode) return false; // Cannot "win" in custom mode

                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        // Check if any cell is empty OR doesn't match the solution
                        if (currentGrid[r][c] === 0 || (solvedGrid.length > 0 && currentGrid[r][c] !== solvedGrid[r][c])) {
                            statusMessage.textContent = ""; // Not won yet
                            return false;
                        }
                    }
                }
                // Grid is full AND matches the solution
                statusMessage.textContent = "Congratulations! You solved it!";
                clearSelection();
                // Optionally disable grid/buttons further
                return true;
            }

            /** Counts occurrences of a number on the current grid */
            function countNumberOnGrid(number) {
                let count = 0;
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        if (currentGrid[r][c] === number) count++;
                    }
                }
                return count;
            }

            /** Updates the enabled/disabled state of number pad buttons */
            function updateNumberPadState() {
                for (let n = 1; n <= SIZE; n++) {
                    const count = countNumberOnGrid(n);
                    const button = numberPad.querySelector(`.num-btn[data-number='${n}']`);
                    if (button) {
                        // Disable button only if NOT in custom mode AND count is 9 or more
                        button.disabled = !isCustomMode && (count >= SIZE);
                    }
                }
                // Ensure erase button is always enabled
                const eraseButton = numberPad.querySelector('.num-btn.erase');
                if(eraseButton) eraseButton.disabled = false;
            }

            /** Moves the selected cell using arrow keys */
            function moveSelection(key) {
                if (!selectedCell) return; // Need a cell selected first
                let { row, col } = selectedCell;
                switch (key) {
                    case 'ArrowUp':    row = Math.max(0, row - 1); break;
                    case 'ArrowDown':  row = Math.min(SIZE - 1, row + 1); break;
                    case 'ArrowLeft':  col = Math.max(0, col - 1); break;
                    case 'ArrowRight': col = Math.min(SIZE - 1, col + 1); break;
                }
                const newCellElement = getCellElement(row, col);
                if (newCellElement) {
                    selectCell(row, col, newCellElement); // Select the new cell
                }
            }

            // --- Hidden Single Logic ---
            // These functions should work correctly in custom mode as well.

             /**
             * Checks if a given number is a "Hidden Single" for a specific empty cell.
             */
             function checkHiddenSingle(row, col, num) {
                // --- Check Row ---
                let foundInRowElsewhere = false;
                for (let cCheck = 0; cCheck < SIZE; cCheck++) {
                    if (cCheck !== col && currentGrid[row][cCheck] === 0) { // Check only other *empty* cells
                        if (getPossibleNumbers(currentGrid, row, cCheck).includes(num)) {
                            foundInRowElsewhere = true;
                            break;
                        }
                    }
                }
                 // If num is a possibility here, but not in any other empty cell in the row -> Hidden Single
                if (!foundInRowElsewhere && getPossibleNumbers(currentGrid, row, col).includes(num)) return true;

                // --- Check Column ---
                let foundInColElsewhere = false;
                for (let rCheck = 0; rCheck < SIZE; rCheck++) {
                    if (rCheck !== row && currentGrid[rCheck][col] === 0) { // Check only other *empty* cells
                        if (getPossibleNumbers(currentGrid, rCheck, col).includes(num)) {
                            foundInColElsewhere = true;
                            break;
                        }
                    }
                }
                 // If num is a possibility here, but not in any other empty cell in the col -> Hidden Single
                if (!foundInColElsewhere && getPossibleNumbers(currentGrid, row, col).includes(num)) return true;

                // --- Check Block ---
                let foundInBlockElsewhere = false;
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let rCheck = startRow; rCheck < startRow + BOX_SIZE; rCheck++) {
                    for (let cCheck = startCol; cCheck < startCol + BOX_SIZE; cCheck++) {
                        // Check only other *empty* cells in the block
                        if ((rCheck !== row || cCheck !== col) && currentGrid[rCheck][cCheck] === 0) {
                            if (getPossibleNumbers(currentGrid, rCheck, cCheck).includes(num)) {
                                foundInBlockElsewhere = true;
                                break;
                            }
                        }
                    }
                    if (foundInBlockElsewhere) break;
                }
                 // If num is a possibility here, but not in any other empty cell in the block -> Hidden Single
                 if (!foundInBlockElsewhere && getPossibleNumbers(currentGrid, row, col).includes(num)) return true;

                return false; // Not a hidden single in row, col, or block
            }


            /**
             * Iterates through all empty cells and updates the styling of their notes
             * to bold any "Hidden Singles".
             */
            function updateHiddenSingleNotes() {
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        const cellElement = getCellElement(r, c);
                        if (!cellElement || currentGrid[r][c] !== 0) continue; // Only empty cells

                        const notesGrid = cellElement.querySelector('.notes-grid');
                        if (!notesGrid) continue;

                        const possibleNotes = getPossibleNumbers(currentGrid, r, c);

                        for (let n = 1; n <= SIZE; n++) {
                            const noteCell = notesGrid.querySelector(`.note-cell[data-note='${n}']`);
                            if (!noteCell) continue;

                            noteCell.classList.remove('hidden-single'); // Reset first

                            // Check only if 'n' is actually a possible note for this cell
                            if (possibleNotes.includes(n)) {
                                if (checkHiddenSingle(r, c, n)) {
                                    noteCell.classList.add('hidden-single');
                                }
                            }
                        }
                    }
                }
            }


            // --- Initialization ---
            console.log("Initializing Sudoku...");
            createGridDOM(); // Build the HTML grid structure
            // Attach listeners
            numberPad.querySelectorAll('.num-btn').forEach(button => {
                button.addEventListener('click', handleNumberClick);
            });
            // Use setupNewGame for both button click and difficulty change
            newGameBtn.addEventListener('click', setupNewGame);
            difficultySelect.addEventListener('change', setupNewGame);
            document.addEventListener('keydown', handleKeyDown); // Global key listener

            setupNewGame(); // Start the first game based on default selection
            console.log("Sudoku Initialized.");

        });
    </script>
</body>
</html>