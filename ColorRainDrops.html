<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Dynamics Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-black">
    <canvas id="fluidCanvas"></canvas>

    <script>
        // --- Main Simulation Setup ---

        const canvas = document.getElementById('fluidCanvas');
        const ctx = canvas.getContext('2d');

        // Simulation parameters
        const N = 128; // Grid size (resolution)
        const iter = 4; // Solver iterations
        const dt = 0.1; // Time step
        const diff = 0.0000; // Diffusion rate
        const visc = 0.0000; // Viscosity

        let fluid;
        let scaleX, scaleY; // Dynamic scaling factors for rendering

        // --- Fluid Solver Class ---

        class Fluid {
            constructor(dt, diffusion, viscosity) {
                this.size = N;
                this.dt = dt;
                this.diff = diffusion;
                this.visc = viscosity;

                // Velocity fields
                this.Vx = new Float32Array(N * N).fill(0);
                this.Vy = new Float32Array(N * N).fill(0);
                this.Vx0 = new Float32Array(N * N).fill(0);
                this.Vy0 = new Float32Array(N * N).fill(0);

                // Density fields (for colors)
                this.densityR = new Float32Array(N * N).fill(0);
                this.densityG = new Float32Array(N * N).fill(0);
                this.densityB = new Float32Array(N * N).fill(0);
                this.sR = new Float32Array(N * N).fill(0);
                this.sG = new Float32Array(N * N).fill(0);
                this.sB = new Float32Array(N * N).fill(0);
            }

            // Indexing helper
            IX(x, y) {
                x = Math.max(0, Math.min(N - 1, x));
                y = Math.max(0, Math.min(N - 1, y));
                return x + y * N;
            }

            // Add density (color) to a cell
            addDensity(x, y, r, g, b) {
                const index = this.IX(x, y);
                this.densityR[index] += r;
                this.densityG[index] += g;
                this.densityB[index] += b;
            }

            // Add velocity to a cell
            addVelocity(x, y, amountX, amountY) {
                const index = this.IX(x, y);
                this.Vx[index] += amountX;
                this.Vy[index] += amountY;
            }

            // Main simulation step
            step() {
                const visc = this.visc;
                const diff = this.diff;
                const dt = this.dt;
                const Vx = this.Vx;
                const Vy = this.Vy;
                const Vx0 = this.Vx0;
                const Vy0 = this.Vy0;
                
                diffuse(1, Vx0, Vx, visc, dt);
                diffuse(2, Vy0, Vy, visc, dt);
                project(Vx0, Vy0, Vx, Vy);
                advect(1, Vx, Vx0, Vx0, Vy0, dt);
                advect(2, Vy, Vy0, Vx0, Vy0, dt);
                project(Vx, Vy, Vx0, Vy0);
                diffuse(0, this.sR, this.densityR, diff, dt);
                diffuse(0, this.sG, this.densityG, diff, dt);
                diffuse(0, this.sB, this.densityB, diff, dt);
                advect(0, this.densityR, this.sR, Vx, Vy, dt);
                advect(0, this.densityG, this.sG, Vx, Vy, dt);
                advect(0, this.densityB, this.sB, Vx, Vy, dt);
            }
        }

        // --- Core Solver Functions (Navier-Stokes equations simplified) ---

        function set_bnd(b, x) {
            for (let i = 1; i < N - 1; i++) {
                x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
                x[IX(i, N - 1)] = b === 2 ? -x[IX(i, N - 2)] : x[IX(i, N - 2)];
            }
            for (let j = 1; j < N - 1; j++) {
                x[IX(0, j)] = b === 1 ? -x[IX(1, j)] : x[IX(1, j)];
                x[IX(N - 1, j)] = b === 1 ? -x[IX(N - 2, j)] : x[IX(N - 2, j)];
            }

            x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
            x[IX(0, N - 1)] = 0.5 * (x[IX(1, N - 1)] + x[IX(0, N - 2)]);
            x[IX(N - 1, 0)] = 0.5 * (x[IX(N - 2, 0)] + x[IX(N - 1, 1)]);
            x[IX(N - 1, N - 1)] = 0.5 * (x[IX(N - 2, N - 1)] + x[IX(N - 1, N - 2)]);
        }

        function lin_solve(b, x, x0, a, c) {
            const cRecip = 1.0 / c;
            for (let k = 0; k < iter; k++) {
                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        x[IX(i, j)] = (x0[IX(i, j)] + a * (x[IX(i + 1, j)] + x[IX(i - 1, j)] + x[IX(i, j + 1)] + x[IX(i, j - 1)])) * cRecip;
                    }
                }
                set_bnd(b, x);
            }
        }

        function diffuse(b, x, x0, diff, dt) {
            const a = dt * diff * (N - 2) * (N - 2);
            lin_solve(b, x, x0, a, 1 + 6 * a);
        }

        function project(velocX, velocY, p, div) {
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    div[IX(i, j)] = -0.5 * (velocX[IX(i + 1, j)] - velocX[IX(i - 1, j)] + velocY[IX(i, j + 1)] - velocY[IX(i, j - 1)]) / N;
                    p[IX(i, j)] = 0;
                }
            }
            set_bnd(0, div);
            set_bnd(0, p);
            lin_solve(0, p, div, 1, 6);

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    velocX[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) * N;
                    velocY[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) * N;
                }
            }
            set_bnd(1, velocX);
            set_bnd(2, velocY);
        }

        function advect(b, d, d0, velocX, velocY, dt) {
            let i0, i1, j0, j1;
            const dtx = dt * (N - 2);
            const dty = dt * (N - 2);
            let s0, s1, t0, t1;
            let tmp1, tmp2, x, y;
            const Nfloat = N - 2;
            let ifloat, jfloat;
            let i, j;

            for (j = 1, jfloat = 1; j < N - 1; j++, jfloat++) {
                for (i = 1, ifloat = 1; i < N - 1; i++, ifloat++) {
                    tmp1 = dtx * velocX[IX(i, j)];
                    tmp2 = dty * velocY[IX(i, j)];
                    x = ifloat - tmp1;
                    y = jfloat - tmp2;

                    if (x < 0.5) x = 0.5;
                    if (x > Nfloat + 0.5) x = Nfloat + 0.5;
                    i0 = Math.floor(x);
                    i1 = i0 + 1.0;
                    if (y < 0.5) y = 0.5;
                    if (y > Nfloat + 0.5) y = Nfloat + 0.5;
                    j0 = Math.floor(y);
                    j1 = j0 + 1.0;

                    s1 = x - i0;
                    s0 = 1.0 - s1;
                    t1 = y - j0;
                    t0 = 1.0 - t1;

                    d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) + s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                }
            }
            set_bnd(b, d);
        }

        function IX(x, y) {
            x = Math.max(0, Math.min(N - 1, x));
            y = Math.max(0, Math.min(N - 1, y));
            return x + y * N;
        }

        // --- Color Conversion ---
        
        /**
         * Converts an HSL color value to RGB.
         * Assumes h, s, and l are in the set [0, 1] and
         * returns r, g, and b in the set [0, 255].
         * @param {number} h The hue
         * @param {number} s The saturation
         * @param {number} l The lightness
         * @returns {Array<number>} The RGB representation [r, g, b]
         */
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }


        // --- Rendering and Animation ---

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    const index = IX(i, j);
                    const r = Math.min(255, Math.max(0, fluid.densityR[index]));
                    const g = Math.min(255, Math.max(0, fluid.densityG[index]));
                    const b = Math.min(255, Math.max(0, fluid.densityB[index]));
                    
                    if (r > 1 || g > 1 || b > 1) {
                         ctx.fillStyle = `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
                         ctx.fillRect(i * scaleX, j * scaleY, scaleX + 1, scaleY + 1); // +1 to avoid gaps
                    }
                }
            }
        }

        function animate() {
            // Add a slight decay to all densities to prevent saturation and keep colors vibrant
            for (let i = 0; i < N * N; i++) {
                const decay = 0.99; // A value slightly less than 1
                fluid.densityR[i] *= decay;
                fluid.densityG[i] *= decay;
                fluid.densityB[i] *= decay;
            }

            fluid.step();
            render();
            requestAnimationFrame(animate);
        }

        // --- Initialization and Event Handling ---

        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            scaleX = canvas.width / N;
            scaleY = canvas.height / N;
        }

        function init() {
            handleResize();
            fluid = new Fluid(dt, diff, visc);
            
            // Add random color drops every second
            setInterval(() => {
                const dropRadius = 6; // Radius of the drop area
                // Ensure the drop's center isn't right at the edge
                const x = Math.floor(Math.random() * (N - dropRadius * 2)) + dropRadius;
                const y = Math.floor(Math.random() * (N - dropRadius * 2)) + dropRadius;
                
                // Generate a bright, saturated color using HSL
                const hue = Math.random(); // 0 to 1 for full color wheel
                const saturation = 1.0; // 100% saturation
                const lightness = 0.5; // 50% lightness for max brightness
                
                const [r, g, b] = hslToRgb(hue, saturation, lightness);

                // Add density in a circular area to create a larger drop
                for (let i = -dropRadius; i <= dropRadius; i++) {
                    for (let j = -dropRadius; j <= dropRadius; j++) {
                        const distance = Math.sqrt(i * i + j * j);
                        if (distance <= dropRadius) {
                            // The color is brightest at the center and fades out
                            const falloff = 1 - (distance / dropRadius);
                            fluid.addDensity(x + i, y + j, r * falloff, g * falloff, b * falloff);
                        }
                    }
                }
                
                const angle = Math.random() * 2 * Math.PI;
                const force = 5000; // Increased force for a more powerful splash
                // Add the velocity force at the center of the drop
                fluid.addVelocity(x, y, Math.cos(angle) * force, Math.sin(angle) * force);

            }, 1000);

            animate();
        }
        
        window.addEventListener('resize', handleResize);

        init();

    </script>
</body>
</html>
